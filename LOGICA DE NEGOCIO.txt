


GENERAL

Controllers: se crea el endpoint que llama a cierto servicio.
Services: se crea el servicio que consume a otro servicio, se da formato o transforma a los datos y retorna esos datos ya modificados.

En un post, se debe verificar la documentación que proporciona el cliente para saber como quiere los datos.

El id de cotización caduca. ******

Entre aseguradoras las claves de coche pueden cambiar asi como las peridicidad pago y nombres de los paquetes. ****


Procesos técnicos ---------------------------------

Hay dos jar en la nube: dev y prod
Los nuevos cambios se suben a dev y lo testean los de qa.
Si pasan las pruebas se suben los cambios de dev a prod.

Negocios -------------------------------------------

ahorra: el negocio principal.
go: es otro negocio donde se dan precios distintos.
	Si la aseguradora lo solicita, se mete este otro negocio.

Endpoints --------------------------------

como sé como debo entregarle la respuesta al fron? Que atributos, con que formato, etc
Para mandar los objetos json que representan las cotizaciones, emisión y pago siempre tienen la misma estructura. Todo eso esta homologado sin importar cual aseguradora se consuma.

porque se permite las solicitudes de cualquier fron y no de uno en especifico?
los del fron no saben que dominio tienen por eso se pone el asterisco

Find car: Ocupado por pla para realizar emisiones masivas.

extracion: Lo de la extracción solo es ejecutado en desarrollo.


/////////////////////////////////////////////CLUP//////////////////////////////////////////////////

Documentación que manda este cliente:
https://documenter.getpostman.com/view/18868163/2sA3QniZYU#3e85c796-b075-4d9e-b44c-bbdcbc97b69c

Para generar la emisión primero es la cotización. Con base al id de la cotización rastreas la emisión.

De 'respositories/caralogRepositories' donde viven esas tablas y como las podria consultar?
Del application.yml extraer la url, username y password, meterlos al dbeaver.
	url: rds-ws-clupp.cypym5wo7yt3.us-east-1.rds.amazonaws.com


Usar endpoints de nuestro proyecto --------------------------------------------

°°°°°°°° Quote °°°°°°°°

Se manda un cuerpo como este que inclye: datos del cliente, el vehiculo
que quiere cotizar y el tipo de paquete que solicita.

Pe este:

{
   "aseguradora":"CLUPP",
   "clave":"CC-07546-01",
   "cp":"66005",
   "descripcion":"ILX",
   "detalle":"PREMIUM 4P L4 2.0L SPORTSHIFT AUT., 05 OCUP.",
   "descuento":0,
   "edad":41,
   "fechaNacimiento":"1984-01-01",
   "genero":"M",
   "marca":"ACURA",
   "modelo":"2013",
   "movimiento":"COTIZACION",
   "servicio":"PARTICULAR",
   "paquete":"AMPLIA-NORMAL",
   "periodicidadPago":"ANUAL",
   "tipoValor":"CONVENIDO",
   "conductorUniversal":false
}

Quizas se elmine el siguiente grupo de texto:
Lo ideal es que de la respuesta, se toma/copia absolutamente todo y se pega en el cuerpo de la solicitud de 
post/issue-policy. Una vez ahi, se deben llenar los datos del cliente y vehiculo.
Sin embargo, lo mejor es solo tomar el idCotizacion y usarlo en el otro endpoint.

De la respueta de la cotización se copian todos los datos dentro de los objetos que representan al vehiculo, coberturas y cotización 
(todos estos objetos deben estar llenos de informacion) pero mas aparte se agrega en el vehiculo: numero de motor, numero de series 
y números de placas. 

Datos del cliente: 

tipo de persona física o moral.
numero de teléfono y correo tienen que ser reales pero no proipios porque si no te llenan de spam.


Datos del vehiculo:

marca, modelo, servicio submarca (ya vienen), placas (puede ser falso), numero de serie (se saca de una pagina random Vin), numero de motor (puede ser falso o ficticio, sin embargo tienen que ser 14 caracteres
entre números y letras), numero de placas (tienen que ser 7 caracteres).

Random Vim: https://randomvin.com/


°°°°°°°° Post issue-policy °°°°°°°°


Responde 'emisión' que viene a ser la póliza.

la respuesta del qoute 
coberturas son todos los paquetes 

prima neta: precio antes de impuestos
prima total: lo que tiene que pagar el cliente en el lapso de tiempo que el haya elegido.

idCotizacion: Este valor es el que interesa usar en issue (emision)

rfc: debe ser un valor existente (bueno cambiarle un solo valor) porque clupp si lo valida bien.


CODIGO CLUPP

Controllers -----------------------------------------------------------

CatalogController:
	- Brand: Crea una lista de las marcas mas vendidas y le concatena las marcas que hay en nuestra
		db después logicamnete nos quedamos con los elementos distintos.
	- anio: Se manda a llamar a los años dispoinibles por marca, este parámetro se recibe por parámetro
		en la url.
	- model: Se manda a llamar a las submarcas dispoinibles por marca y año, estos parámetros se 
		reciben por parámetros en la url.
	- variants: Se manda a llamar las claves y descripciones de autos dispoinibles por submarcas, marca 		y año, estos parámetros se reciben por parámetros en la url.
	- findCar:  dispoinible por clave y año, estos parámetros se reciben por parámetros en la url.

ExtraccionCatalogController:
	- getMarcas: Consulta las marcas de la api de clup con base al tipo de vehiculo. El tipo de 
		vehiculo se envia el la url. 
		Este controller tiene el propósito de saber si el método 'getMarcas' del clase 				'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getModelos:  Consulta los modelos de la api de clup con base al tipo de vehiculo y marca. Estos
		parámetros se envian el la url. 
		Este controller tiene el propósito de saber si el método 'getModelos' del clase 			'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getAnios: Consulta los años de la api de clup con base al tipo de vehiculo, marca y version.
		Estos parámetros se envian el la url. 
		Este controller tiene el propósito de saber si el método 'getModelos' del clase 			'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getProducto: Consulta el producto (toda la información del carro)*** de la api de clup con base 		al tipo de vehiculo, marca, versión y años. Estos parámetros se envian el la url. 
		Este controller tiene el propósito de saber si el método 'getModelos' del clase 			'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getAllExtrac: Usando un mismo tipo de vehiculo, se mandan a llamar todas las marcas, por cada
		marca se mandan a llamar todas las submarcas, por cada submarca se mandan a llamar todos
		los años (en si desde el año 2000 hasta el 2027, quien sabe porque). 
		Con base a esta información se obtienen los productos.
		Después se buscan las variantes del qualitas y si no se encuentran aquí se buscan en 
		Banorte.
		(si al buscar la variante en qualitas los atributos: id, marca o modelo no existen o si
		el id existe pero contiene un null no hubo resultado y es necesario buscar en Banorte)
		Finalmente se guarda la información del producto en la db pero añadiendo las variantes
		de este.

QuoteController: Hace la cotización.
	- postQuote: Mediante la url recibe el tipo de negocio (ahorra ó go) y llama al método service
		que hace la cotización dependientemente si es all o amplia.

issuePolicy: Hace la póliza.
	- issuePolicy: Mediante la url recibe el tipo de negocio (ahorra ó go) y llama al método service
		que hace la emision.


services -----------------------------------------------------------

CatalogService: Manda a llamar a las marcas; año por marcas; submarca por año y marca; variants por 	submarca, marca y año y findCar por clave y año de nuestra db.

QuoteService: 
	- postQuote: Verificar que el servicio de cotización este activo.


IssueService:
	- mapToCluppRequest: Convierte el json que mandamos al json que entienda clup.
	- processCluppResponse: Agrega valores por defecto a unos atributos del objeto de la póliza 
		si estos vienen vacíos.
	- issuePolicy: Con base al cuerpo que mandamos en la solicitud, toma unos datos y crea
		el cuerpo que solicita clup para hacer la poliza.
		Después a la respuesta de la póliza se le da formato (En si solo le asigna valores por 			defectos a los atributos que vengan vacíos).
		Actualiza el json que mandamos en la solicitud, agregando nuevos datos de la poliza
	

Repositories -----------------------------------------------------------

La consulta para obtener las marcas en promedio tarda entre 87ms y 110ms.


°°°°°°°°° CatalogRepositories °°°°°°°°°°°°°°°

Se debería reemplazar la consulta marca por esta:

WITH marcas_distintas AS (
        SELECT DISTINCT marca
        FROM ExtraccionCluppNoviembre2024
    )
    SELECT 
        ROW_NUMBER() OVER (ORDER BY marca) AS id,
        marca AS text
    FROM marcas_distintas;

Se debería reemplazar la consulta modelo por esta:

SELECT 
    ROW_NUMBER() OVER (ORDER BY modelo DESC) AS id,
    modelo AS text
FROM ExtraccionCluppNoviembre2024
WHERE marca = 'AUDI'
GROUP BY modelo
ORDER BY text DESC;

models ------------------------------------

Carpeta Catalog:
	Cuando se busca en la db, para almacenar el resultado de marca, año, submarca y variantes se usa 
	el mismo modelo.
	Cuando se busca en la db, para almacenar el resultado de findCar se usa otro modelo.



/////////////////////////////////////////////EL AGUILA/////////////////////////////////////////////////

Hay dos proyectos que representan a esta seguradora: el águila (es el mas nuevo pero aun no se lanza
porque falta corregir un descuadre (es problema de la aseguradora)) y el águila core (es el mas
viejo pero como aun no se lanza el otro, este es el que actualmente se usa).


EL AGUILA

Este se revisa. Esta en su versión 4.

Ahorita hay un descuadre por parte de esta aseguradora, en el paquete de cobertura 100.

documentación de catalogos: no hacerle tanto caso, porque el águila tiene su propio servicio de extracción.

documentación de la aseguradora: únicamente hay para cotización y no hay servicio emisión.

.pdf -> Estudiarle para saber que moverle.
	Específicamente los servicios de cotización.

.XML -> se abre con el soapUi.

collection Cat calcula -------------------
	
De todos los servicios que vienen en el XML el que interesa es cotizaAguila. Para cotizar se necesita el modelo del auto, el idModeloAuto, el subRamo (siempre vale 'R' (residente)), la fecha de nacimiento (checar documentación para saber el formato //), genero del cliente, estado civil, nombre y apellidos del cliente, numTelefono, correo, la contraseña nunca cambia. 
Solo permite cotizar del año 2012 al 2026.


collection Cat cotizador -------------------

para consultar catalogos de auto.
valida el cp, 
marca: devuelve todas las marcas de auto dependiendo del año, 
modelo: devuelve los años disponibles para cotizar.


Consumir el cliente ----------------------------

Pasos para cotizar:

Primero consumir el endpoint subramo y se extrae el valor (aunque siempre se debe utilizar el valor 'R')
consumir modelo de auto: se mete el subramo aquí y se extrae algún año valido.
consumir el servicio de marca ingresando el año y se extrae la marca y idMarca
consumir el servicio de submarca: colocar los datos anteriores, se extrae el idSubmarca y submarca
consumir el servicio de submarcaTipo: colocar todos los datos anteiorres y extraer la clave (modelo 
del auto).

Ahora a cotizar usando el endpoint cotizaAguila, se coloca el modelo del auto (año de auto), submarcaTipoId y un cp valido (11000 para cdmx). Si se gusta se modifica la info del cliente pe si se modifica su estado civil se obtiene un descuento distintos. La respuesta son: los paquetes y coberturas.

Pe:
subRamo: R
intModeloAuto (año): 2019
intMarca (idMarca): 10 
strDesMarca (Marca): BMW
intTipo (idSubMarca): 126
SubMarca: BMW SERIE 3
intModelo (submarcaTipoId): 5623


CODIGO DEL AGUILA 


paquete catalog --------------------------------

°°°°°° controllers °°°°°°°°

ExtractionController -> Sirve para usar todos los enpoints necesarios para hacer la cotización pero extrae
	esos catalogos y se guardan en nuestra db para que supongo después las muestre el front en 	selectores.*
	Al inicio de cada lista se concatena (para que aparezca primero en el fron) las categorías
	mas vendidas.
	Pe es necesario consultar los modelos (todos los años disponibles) para cotizar, todos esos años
	se guardan en catalogos.

CatalogCarController -> Tiene un endpoint por catalogo para verificar que se extrajo todo correctamente.


°°°°°° models °°°°°°°°


Tal cual contiene las clases entity y un enum (esta mal el nombre)

°°°°°° Repositories °°°°°°°°

En su mayoría muy normal, puras clases que hacen consultas personalizadas y nativas, salvo por dos 
clases.
Estas dos clases tiene operaciones de truncate y reinicio de secuencia (del id) porque cuando se extraen los catalogos de cliente se borran los que tenemos en nuestra db y reiniciamos la secuencia y volvemos a
extraer.


°°°°°° xmls °°°°°°°°

Contiene plantillas XML que son usados para enviar cuerpos de solicitud a las peticiones soap.
Esta carpeta no debería existir.


°°°°°° services °°°°°°°°

catalogService: contiene el acceso a nuestra db para la pura devolución de los catalogos. 
	El mas fácil.

ExtractSErvice: Consulta todos los catalogos del api soap y los guarda en nuestra db.
	Para hacerlo Manda a llamar los métodos de DataExtractService y GetExtractService.

DataExtractService: Hace un especie de polimorfismo porque hace un switch case que pregunta si es de tal
	tipo haz tal cosa.
	Solo hay dos operaciones: 1. hacer truncate y reinicio de secuencia y 2.

GetExtractService: Contiene los métodos que usan de manera individual los endpoints para hacer
	la cotización.
	Usa las plantillas XML.


paquete quote --------------------------------

°°°°°° controllers °°°°°°°°

QuoteController: Srive para cotizar


°°°°°° services °°°°°°°°

QuoteService: 
	- codPost: extrae el cp que viene en el cuerpo de una respuesta, y verifica si es o no valido
		dependiendo si tiene el valor true o false.
		Este método no debería estar aquí, debería ser parte del metodo cp.
	- quote: contiene el método el cual se encarga de cotizar.
		Valida el paquete y genero del cliente, cp y que los seriviios de la aseguradora esten 
		activos. Si todo esta correcto, prepara los datos para la cotización y después cotiza.
		Cotiza solo anulidades, mete a mano los planes y manda la respuestas.

GetCPService: 
	- cp: hace la petición para verificar un cp valido.

GetQuoteService:
	- xmlCot: hace la petición para la cotización.

°°°°°° models °°°°°°°°

todo normal clases entity y dto


°°°°°° repository °°°°°°°°

la única consulta sirve para verificar que los seriviios de la aseguradora esten activos, para saber si
se puede o no cotizar.

 
EL AGUILA (CORE)

Es el proyecto mas viejo pero se usa actualmente para cotización y tampoco hay servicio de emisión.

Cuando se arregle el descuadre del otro, el otro reemplazara a este.

consumir el proyecto con postman ------------------------------------

Consumir catalogos:

Primero las marcas
Después el año y se inserta una marca
Después models insertando año y marca
Después variants insertando años, marca y modelo.

Para variants {{DEV}}/v2/elaguila-car/variants?brand=NISSAN&year=2021&model=MARCH

Realizar cotización:

En el cuerpo de la respuesta se de observar que se esten presentes los mismos datos del coche que se 
están mandando y además los valores para prima total, prima neta, derechos (valor numerico), recargos,
primero pago, id de cotización, las coberturas.



CODIGO DEL AGUILA (CORE)

De todo el repositorio, el proyecto esta dentro de la carpeta java.
Se debe usar jdk 22 de openJdk.

Documentación swagger: https://ws-aguila.com/swagger-ui/index.html

Controllers -----------------------------------------------------

CatalogosControllerV1:
	- getMarca: Llama al método getMarcas.
	- getModelo: Llama al método getModelo con la marca la cual la recibe por parmetro en la url.
	- getSubmarca: Llama al método getSubmarca con la marca y modelo las cuales las recibe por parmetro 		en la url.
	- getDescripcion: Llama al método getDescripcion con la marca, modelo y submarca las cuales las 		recibe por parmetro en la url.

CatalogosControllerV2: Al parcer manda a llamar a los mismos métodos que manda a llamar la v1.
	No hay versión 3 porque algunos proyectos estaban ya en v3, entonces se paso directamente a la
	v4. Para la v4 ya no se uso el cache porque se determino que no se necesita por haber muy poca
	cantidad de registros.

CotizacionControllerV1: 
	- quote: Recibe un objeto y de ese objeto toma el atributo paquete y evalúa diversos caminos: si
		el paquete tiene el valor ALL, Amplia o si tiene otro valor lanzara un error.
		Si el paquete tiene el valor all llamara al método cotización all del objeto 				CotizacionService
		Si el paquete tiene el valor amplia llamara al método cotizar del objeto 				CotizacionService
	- go: Al parecer hace la cotización pero para el negocio de go.


services -----------------------------------------------------

CatalogosService: Usa multiples repositories de distintas entidades.
	- getMarcas: Al inicio escribe manualmente las marcas mas vendidas y le concatena la consulta 
		a nuestra db para extraer todas las marcas (con el objeto MarcasRepository), de todas 
		estas lógicamente nos quedamos con solo elementos distintos.
	- getModelo: Hace la consulta a nuestra db para extraer todas los modelos con base a la marca 
		(con el objeto ModelosRepository).
	- getSubmarca: Hace la consulta a nuestra db para extraer todas las submarcas con base a la marca 
		y modelo (con el objeto SubmarcaRepository).
	- getDescripcion: Hace la consulta a nuestra db para extraer todas las descripciones con base a 
		la marca, submarcas y modelo (con el objeto DescripcionRepository).
	- Los mismos anteriores métodos pero en cache.

CotizacionService:
	- cotizar:  De manera general hace una cotización para un solo plan.
		De lo mas relevante que hace son dos cosas:
		1. Este constructor 'BasicHttpsBinding_ICalculoAguilaStub()' se conecta a una URL 
		(con extensión .svc) y configura un stub, que es un cliente SOAP generado automáticamente. 		Este stub te permite invocar métodos del servicio SOAP remoto como si fueran funciones 			locales en Kotlin o Java.
		2. El objeto llamado 'calculo' es un objeto que contiene al atributo '_any' el cual es 
		un arreglo de objetos XML 
	- cotizarAll: Al parecer hace la misma cotización (en el sentido de que usa el mismo servicio de 		cotizacion) pero usa otro tipo de clase para instanciar el objeto de la respuesta en 			comparación con el que utilizar el método cotizar. Esto sucede porque a pesar de que se
		usa el servicio una sola vez, aquí se arma una cotizacion para tres planes: Amplia, 			AmpliaBásica y Cobertura100
		Cotizar all usa la clase ResponseAll() y cotizar usa la clase Response.


repositories -----------------------------------------------------

Todo normal, puras consultas. Pero hay algunas consultas medio insanas.


models -----------------------------------------------------

Todo normal, aunque hay varias anotaciones JsonProperty de mas.


CUALQUIER PROYECTO


Primero me enseñaron a usar los endpoints de la aseguradora.
Después replique ese consumo por mi cuenta por mi cuenta.

Después ya revise flujo por flujo los endpoint's, comenzando por los endpoints.
Anote por cada paquete y cada clase, que hace cada método dentro de él. ESto con la finalidad de que no 
se me olvide anotar el comportamiento de cada método.

Después me enseñaron a usar los endpoints resultantes.
Replicarlo por mi cuenta.




/////////////////////////////////////////////TEORIA/////////////////////////////////////////////////////


GLOSARIO

Cotización de seguro vehicular: es el proceso mediante el cual una aseguradora calcula y te informa cuánto te costaría contratar un seguro para tu auto, de acuerdo con ciertos datos que tú proporcionas. Entre estos
datos pueden ser: genero y edad del cliente, marca y modelo del coche, nivel de cobertura (tipo de paquete), etc.

Periodicidad de pago: frecuencia con la que el cliente desea pagar el seguro.

nivel de cobertura: se refiere a qué tanto te protege el seguro y contra qué riesgos. Es decir, cuáles cosas cubre y cuáles no en caso de accidente, robo, daños, etc.
Se puede entender como que cada nivel tiene un paquete de beneficios distinto.

emisión: Es el contrato que se genera una vez que el cliente adquiere el seguro.
	id de la póliza (contrato)
	En la documentación de las aseguradoras viene que hacen primero: 1. si cobran y después generan
	la pliza o 2. si primero generan la póliza y después cobran.

descuentos: varia entre aseguradora.
	En temporada alta suben los descuentos: hot sale, buen fin, etc.

descuadre de precios: Se da en el servicio de cotización.
	El problema normalmente serán las coverturas (Viene mal el precio en determinado paquete)

los comercial: personas de nuestra compañía que consumen nuestros servicios. 
	Ellos mandan las incidencias (los descuadres, el paquete no es ese, fecha invalida, etc).

Derechos, Derechos de póliza ó derechos de emisión: son cargos adicionales fijos aplicados al emitir 
	una póliza de seguro, independientes de la prima.

primaNeta: es el costo puro del seguro, sin impuestos ni cargos.

primaTotal: la suma de todos los conceptos: prima neta + impuestos + derechos + recargos.



ENDPOINTS

PathVariable ------------------------------------

En todos los endpoint de cualquier proyecto donde este {business} se escribe ahorra y es el único posible valor que puede tomar.



Post ---------------------------------------------

En un método post, esto son los posibles valores que se pueden mandar para ciertos atributos:

tipo de valor: Siempre será 'convenido' a menos que la aseguradora indique que cambies el valor.
Periodicidad de pago: anual, semestral, trimestral, mensual, contado.
servicio: 
	particular: para autos normales
	motoApp: para aplicaciones como uber, didi.
	pickup: camionatas (cherokee).

cp: tiene que ser un valor real y existente.
tipo persona: F (hace referencia a persona fisica).
fecha: yyyy-mm-dd
población: va el municipio 
