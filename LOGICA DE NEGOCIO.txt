





GENERAL

Controllers: se crea el endpoint que llama a cierto servicio.
Services: se crea el servicio que consume a otro servicio, se da formato o transforma a los datos y retorna esos datos ya modificados.

En un post, se debe verificar la documentación que proporciona el cliente para saber como quiere los datos.

El id de cotización caduca. ******

Entre aseguradoras las claves de coche pueden cambiar asi como las peridicidad pago y nombres de los paquetes. ****

pick ups: camionetas.

líneas de negocio: tipo de seguro que una aseguradora ofrece
	Pe Seguro para vehículos personales, Autos comerciales, Gastos médicos mayores, vida, etc.

prima base: Es el precio del seguro para los datos del vehiculo (TIPO_VEHICULO, ARMADORA, CARROCERIA, VERSION, MODEL, ETC) y paquete seleccionado. **


Procesos técnicos ---------------------------------

Hay dos jar en la nube: dev y prod
Los nuevos cambios se suben a dev y lo testean los de qa.
Si pasan las pruebas se suben los cambios de dev a prod.

cuando se haga cuadre de precios:
siempre nos deben mandar datos para hacer la cotización.


Negocios -------------------------------------------

ahorra: el negocio principal.
go: es otro negocio donde se dan precios distintos.
	Si la aseguradora lo solicita, se mete este otro negocio.

Endpoints --------------------------------

como sé como debo entregarle la respuesta al fron? Que atributos, con que formato, etc
Para mandar los objetos json que representan las cotizaciones, emisión y pago siempre tienen la misma estructura. Todo eso esta homologado sin importar cual aseguradora se consuma.

porque se permite las solicitudes de cualquier fron y no de uno en especifico?
los del fron no saben que dominio tienen por eso se pone el asterisco

Find car: Ocupado por pla para realizar emisiones masivas.

extracion: Lo de la extracción solo es ejecutado en desarrollo.

Si se usa el negoio de ahorra siempre el 'tipo de valor' será 'comercial' (haciendo referencia que es un
precio para todos) pero si el negocio es go el tipo
de valor será 'convenido' (haciendo referencia de )


/////////////////////////////////////////////CLUP//////////////////////////////////////////////////

Documentación que manda este cliente:
https://documenter.getpostman.com/view/18868163/2sA3QniZYU#3e85c796-b075-4d9e-b44c-bbdcbc97b69c

Para generar la emisión primero es la cotización. Con base al id de la cotización rastreas la emisión.

De 'respositories/caralogRepositories' donde viven esas tablas y como las podria consultar?
Del application.yml extraer la url, username y password, meterlos al dbeaver.
	url: rds-ws-clupp.cypym5wo7yt3.us-east-1.rds.amazonaws.com


Usar endpoints de nuestro proyecto --------------------------------------------

°°°°°°°° Quote °°°°°°°°

Se manda un cuerpo como este que inclye: datos del cliente, el vehiculo
que quiere cotizar y el tipo de paquete que solicita.

Pe este:

{
   "aseguradora":"CLUPP",
   "clave":"CC-07546-01",
   "cp":"66005",
   "descripcion":"ILX",
   "detalle":"PREMIUM 4P L4 2.0L SPORTSHIFT AUT., 05 OCUP.",
   "descuento":0,
   "edad":41,
   "fechaNacimiento":"1984-01-01",
   "genero":"M",
   "marca":"ACURA",
   "modelo":"2013",
   "movimiento":"COTIZACION",
   "servicio":"PARTICULAR",
   "paquete":"AMPLIA-NORMAL",
   "periodicidadPago":"ANUAL",
   "tipoValor":"CONVENIDO",
   "conductorUniversal":false
}

Quizas se elmine el siguiente grupo de texto:
Lo ideal es que de la respuesta, se toma/copia absolutamente todo y se pega en el cuerpo de la solicitud de 
post/issue-policy. Una vez ahi, se deben llenar los datos del cliente y vehiculo.
Sin embargo, lo mejor es solo tomar el idCotizacion y usarlo en el otro endpoint.

De la respueta de la cotización se copian todos los datos dentro de los objetos que representan al vehiculo, coberturas y cotización 
(todos estos objetos deben estar llenos de informacion) pero mas aparte se agrega en el vehiculo: numero de motor, numero de series 
y números de placas. 

Datos del cliente: 

tipo de persona física o moral.
numero de teléfono y correo tienen que ser reales pero no proipios porque si no te llenan de spam.


Datos del vehiculo:

marca, modelo, servicio submarca (ya vienen), placas (puede ser falso), numero de serie (se saca de una pagina random Vin), numero de motor (puede ser falso o ficticio, sin embargo tienen que ser 14 caracteres
entre números y letras), numero de placas (tienen que ser 7 caracteres).

Random Vim: https://randomvin.com/


°°°°°°°° Post issue-policy °°°°°°°°


Responde 'emisión' que viene a ser la póliza.

la respuesta del qoute 
coberturas son todos los paquetes 

prima neta: precio antes de impuestos
prima total: lo que tiene que pagar el cliente en el lapso de tiempo que el haya elegido.

idCotizacion: Este valor es el que interesa usar en issue (emision)

rfc: debe ser un valor existente (bueno cambiarle un solo valor) porque clupp si lo valida bien.


CODIGO CLUPP

Controllers -----------------------------------------------------------

CatalogController:
	- Brand: Crea una lista de las marcas mas vendidas y le concatena las marcas que hay en nuestra
		db después logicamnete nos quedamos con los elementos distintos.
	- anio: Se manda a llamar a los años dispoinibles por marca, este parámetro se recibe por parámetro
		en la url.
	- model: Se manda a llamar a las submarcas dispoinibles por marca y año, estos parámetros se 
		reciben por parámetros en la url.
	- variants: Se manda a llamar las claves y descripciones de autos dispoinibles por submarcas, marca 		y año, estos parámetros se reciben por parámetros en la url.
	- findCar:  dispoinible por clave y año, estos parámetros se reciben por parámetros en la url.

ExtraccionCatalogController:
	- getMarcas: Consulta las marcas de la api de clup con base al tipo de vehiculo. El tipo de 
		vehiculo se envia el la url. 
		Este controller tiene el propósito de saber si el método 'getMarcas' del clase 				'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getModelos:  Consulta los modelos de la api de clup con base al tipo de vehiculo y marca. Estos
		parámetros se envian el la url. 
		Este controller tiene el propósito de saber si el método 'getModelos' del clase 			'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getAnios: Consulta los años de la api de clup con base al tipo de vehiculo, marca y version.
		Estos parámetros se envian el la url. 
		Este controller tiene el propósito de saber si el método 'getModelos' del clase 			'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getProducto: Consulta el producto (toda la información del carro)*** de la api de clup con base 		al tipo de vehiculo, marca, versión y años. Estos parámetros se envian el la url. 
		Este controller tiene el propósito de saber si el método 'getModelos' del clase 			'ExtraccionCatalogService' funciona correctamente porque será mandado a llamar 
		multiples veces dentro de un ciclo. 
	- getAllExtrac: Usando un mismo tipo de vehiculo, se mandan a llamar todas las marcas, por cada
		marca se mandan a llamar todas las submarcas, por cada submarca se mandan a llamar todos
		los años (en si desde el año 2000 hasta el 2027, quien sabe porque). 
		Con base a esta información se obtienen los productos.
		Después se buscan las variantes del qualitas y si no se encuentran aquí se buscan en 
		Banorte.
		(si al buscar la variante en qualitas los atributos: id, marca o modelo no existen o si
		el id existe pero contiene un null no hubo resultado y es necesario buscar en Banorte)
		Finalmente se guarda la información del producto en la db pero añadiendo las variantes
		de este.

QuoteController: Hace la cotización.
	- postQuote: Mediante la url recibe el tipo de negocio (ahorra ó go) y llama al método service
		que hace la cotización dependientemente si es 'all' o 'amplia' el paquete.

issuePolicy: Hace la póliza.
	- issuePolicy: Mediante la url recibe el tipo de negocio (ahorra ó go) y llama al método service
		que hace la emision.


services -----------------------------------------------------------

CatalogService: Manda a llamar a las marcas; año por marcas; submarca por año y marca; variants por 	submarca, marca y año y findCar por clave y año de nuestra db.

QuoteService: 
	- postQuote: Hace la cotización para un solo paqeute (el que reciba el metodo).
		Instancia el objeto json respuesta que será enviado al front. 
		Adapta la clave (que parece ser del coche) a una clave que pueda entender clupp, 			Verifica que el servicio de cotización este activo (si no esta activo mandara un error
		en el objeto json respuesta front y se envia al front), adapta el paquete y periodicidad
		a uno que entienda clupp.
		Instancia el objeto que será usado en la solicitud de cotización (pareciera ser que 
		hacen falta meter los datos del cliente, porque al parecer se meten solo los datos
		del vehiculo) y realiza la petición. Si la respuesta contiene el atributo message 
		siginifica ue ocurrió un error.
		De la respuesta extrae el id, el periodo de cotización y las coberturas.
		El objeto json respuesta que será enviado al front se llena con ciertos datos de la 
		respuesta a la api de clup.
		Se inserta un log.
	- postQuoteAll: Hace la cotización para todos los paquetes disponibles (son solo 3: 
		"AMPLIA-REDUCIDA", "AMPLIA-NORMAL", "AMPLIA-INTENSIVA").
		Manda a llamar dentro de un ciclo al postQuote.*

IssueService:
	- mapToCluppRequest: Convierte el json que mandamos al json que entienda clup.
	- processCluppResponse: Agrega valores por defecto a unos atributos del objeto de la póliza 
		si estos vienen vacíos.
	- issuePolicy: Con base al cuerpo que mandamos en la solicitud, toma unos datos y crea
		el cuerpo que solicita clup para hacer la poliza.
		Después a la respuesta de la póliza se le da formato (En si solo le asigna valores por 			defectos a los atributos que vengan vacíos).
		Actualiza el json que mandamos en la solicitud, agregando nuevos datos de la poliza
	

Repositories -----------------------------------------------------------

La consulta para obtener las marcas en promedio tarda entre 87ms y 110ms.


°°°°°°°°° CatalogRepositories °°°°°°°°°°°°°°°

Se debería reemplazar la consulta marca por esta:

WITH marcas_distintas AS (
        SELECT DISTINCT marca
        FROM ExtraccionCluppNoviembre2024
    )
    SELECT 
        ROW_NUMBER() OVER (ORDER BY marca) AS id,
        marca AS text
    FROM marcas_distintas;

Se debería reemplazar la consulta modelo por esta:

SELECT 
    ROW_NUMBER() OVER (ORDER BY modelo DESC) AS id,
    modelo AS text
FROM ExtraccionCluppNoviembre2024
WHERE marca = 'AUDI'
GROUP BY modelo
ORDER BY text DESC;

models ------------------------------------

Carpeta Catalog:
	Cuando se busca en la db, para almacenar el resultado de marca, año, submarca y variantes se usa 
	el mismo modelo.
	Cuando se busca en la db, para almacenar el resultado de findCar se usa otro modelo.



/////////////////////////////////////////////EL AGUILA/////////////////////////////////////////////////

Hay dos proyectos que representan a esta seguradora: el águila (es el mas nuevo pero aun no se lanza
porque falta corregir un descuadre (es problema de la aseguradora)) y el águila core (es el mas
viejo pero como aun no se lanza el otro, este es el que actualmente se usa).


EL AGUILA

Este se revisa. Esta en su versión 4.

Ahorita hay un descuadre por parte de esta aseguradora, en el paquete de cobertura 100.

documentación de catalogos: no hacerle tanto caso, porque el águila tiene su propio servicio de extracción.

documentación de la aseguradora: únicamente hay para cotización y no hay servicio emisión.

.pdf -> Estudiarle para saber que moverle.
	Específicamente los servicios de cotización.

.XML -> se abre con el soapUi.

collection Cat calcula -------------------
	
De todos los servicios que vienen en el XML el que interesa es cotizaAguila. Para cotizar se necesita el modelo del auto, el idModeloAuto, el subRamo (siempre vale 'R' (residente)), la fecha de nacimiento (checar documentación para saber el formato //), genero del cliente, estado civil, nombre y apellidos del cliente, numTelefono, correo, la contraseña nunca cambia. 
Solo permite cotizar del año 2012 al 2026.


collection Cat cotizador -------------------

para consultar catalogos de auto.
valida el cp, 
marca: devuelve todas las marcas de auto dependiendo del año, 
modelo: devuelve los años disponibles para cotizar.


Consumir el cliente ----------------------------

Pasos para cotizar:

Primero consumir el endpoint subramo y se extrae el valor (aunque siempre se debe utilizar el valor 'R')
consumir modelo de auto: se mete el subramo aquí y se extrae algún año valido.
consumir el servicio de marca ingresando el año y se extrae la marca y idMarca
consumir el servicio de submarca: colocar los datos anteriores, se extrae el idSubmarca y submarca
consumir el servicio de submarcaTipo: colocar todos los datos anteiorres y extraer la clave (modelo 
del auto).

Ahora a cotizar usando el endpoint cotizaAguila, se coloca el modelo del auto (año de auto), submarcaTipoId y un cp valido (11000 para cdmx). Si se gusta se modifica la info del cliente pe si se modifica su estado civil se obtiene un descuento distintos. La respuesta son: los paquetes y coberturas.

Pe:
subRamo: R
intModeloAuto (año): 2019
intMarca (idMarca): 10 
strDesMarca (Marca): BMW
intTipo (idSubMarca): 126
SubMarca: BMW SERIE 3
intModelo (submarcaTipoId): 5623


CODIGO DEL AGUILA 


paquete catalog --------------------------------

°°°°°° controllers °°°°°°°°

ExtractionController -> Sirve para usar todos los enpoints necesarios para hacer la cotización pero extrae
	esos catalogos y se guardan en nuestra db para que supongo después las muestre el front en 	selectores.*
	Al inicio de cada lista se concatena (para que aparezca primero en el fron) las categorías
	mas vendidas.
	Pe es necesario consultar los modelos (todos los años disponibles) para cotizar, todos esos años
	se guardan en catalogos.

CatalogCarController -> Tiene un endpoint por catalogo para verificar que se extrajo todo correctamente.


°°°°°° models °°°°°°°°


Tal cual contiene las clases entity y un enum (esta mal el nombre)

°°°°°° Repositories °°°°°°°°

En su mayoría muy normal, puras clases que hacen consultas personalizadas y nativas, salvo por dos 
clases.
Estas dos clases tiene operaciones de truncate y reinicio de secuencia (del id) porque cuando se extraen los catalogos de cliente se borran los que tenemos en nuestra db y reiniciamos la secuencia y volvemos a
extraer.


°°°°°° xmls °°°°°°°°

Contiene plantillas XML que son usados para enviar cuerpos de solicitud a las peticiones soap.
Esta carpeta no debería existir.


°°°°°° services °°°°°°°°

catalogService: contiene el acceso a nuestra db para la pura devolución de los catalogos. 
	El mas fácil.

ExtractSErvice: Consulta todos los catalogos del api soap y los guarda en nuestra db.
	Para hacerlo Manda a llamar los métodos de DataExtractService y GetExtractService.

DataExtractService: Hace un especie de polimorfismo porque hace un switch case que pregunta si es de tal
	tipo haz tal cosa.
	Solo hay dos operaciones: 1. hacer truncate y reinicio de secuencia y 2.

GetExtractService: Contiene los métodos que usan de manera individual los endpoints para hacer
	la cotización.
	Usa las plantillas XML.


paquete quote --------------------------------

°°°°°° controllers °°°°°°°°

QuoteController: Srive para cotizar


°°°°°° services °°°°°°°°

QuoteService: 
	- codPost: extrae el cp que viene en el cuerpo de una respuesta, y verifica si es o no valido
		dependiendo si tiene el valor true o false.
		Este método no debería estar aquí, debería ser parte del metodo cp.
	- quote: contiene el método el cual se encarga de cotizar.
		Valida el paquete y genero del cliente, cp y que los seriviios de la aseguradora esten 
		activos. Si todo esta correcto, prepara los datos para la cotización y después cotiza.
		Cotiza solo anulidades, mete a mano los planes y manda la respuestas.

GetCPService: 
	- cp: hace la petición para verificar un cp valido.

GetQuoteService:
	- xmlCot: hace la petición para la cotización.

°°°°°° models °°°°°°°°

todo normal clases entity y dto


°°°°°° repository °°°°°°°°

la única consulta sirve para verificar que los seriviios de la aseguradora esten activos, para saber si
se puede o no cotizar.

 
EL AGUILA (CORE)

Es el proyecto mas viejo pero se usa actualmente para cotización y tampoco hay servicio de emisión.

Cuando se arregle el descuadre del otro, el otro reemplazara a este.

consumir el proyecto con postman ------------------------------------

Consumir catalogos:

Primero las marcas
Después el año y se inserta una marca
Después models insertando año y marca
Después variants insertando años, marca y modelo.

Para variants {{DEV}}/v2/elaguila-car/variants?brand=NISSAN&year=2021&model=MARCH

Realizar cotización:

En el cuerpo de la respuesta se de observar que se esten presentes los mismos datos del coche que se 
están mandando y además los valores para prima total, prima neta, derechos (valor numerico), recargos,
primero pago, id de cotización, las coberturas.



CODIGO DEL AGUILA (CORE)

De todo el repositorio, el proyecto esta dentro de la carpeta java.
Se debe usar jdk 22 de openJdk.

Documentación swagger: https://ws-aguila.com/swagger-ui/index.html

Controllers -----------------------------------------------------

CatalogosControllerV1:
	- getMarca: Llama al método getMarcas.
	- getModelo: Llama al método getModelo con la marca la cual la recibe por parmetro en la url.
	- getSubmarca: Llama al método getSubmarca con la marca y modelo las cuales las recibe por parmetro 		en la url.
	- getDescripcion: Llama al método getDescripcion con la marca, modelo y submarca las cuales las 		recibe por parmetro en la url.

CatalogosControllerV2: Al parcer manda a llamar a los mismos métodos que manda a llamar la v1.
	No hay versión 3 porque algunos proyectos estaban ya en v3, entonces se paso directamente a la
	v4. Para la v4 ya no se uso el cache porque se determino que no se necesita por haber muy poca
	cantidad de registros.

CotizacionControllerV1: 
	- quote: Recibe un objeto y de ese objeto toma el atributo paquete y evalúa diversos caminos: si
		el paquete tiene el valor ALL, Amplia o si tiene otro valor lanzara un error.
		Si el paquete tiene el valor all llamara al método cotización all del objeto 				CotizacionService
		Si el paquete tiene el valor amplia llamara al método cotizar del objeto 				CotizacionService
	- go: Al parecer hace la cotización pero para el negocio de go.


services -----------------------------------------------------

CatalogosService: Usa multiples repositories de distintas entidades.
	- getMarcas: Al inicio escribe manualmente las marcas mas vendidas y le concatena la consulta 
		a nuestra db para extraer todas las marcas (con el objeto MarcasRepository), de todas 
		estas lógicamente nos quedamos con solo elementos distintos.
	- getModelo: Hace la consulta a nuestra db para extraer todas los modelos con base a la marca 
		(con el objeto ModelosRepository).
	- getSubmarca: Hace la consulta a nuestra db para extraer todas las submarcas con base a la marca 
		y modelo (con el objeto SubmarcaRepository).
	- getDescripcion: Hace la consulta a nuestra db para extraer todas las descripciones con base a 
		la marca, submarcas y modelo (con el objeto DescripcionRepository).
	- Los mismos anteriores métodos pero en cache.

CotizacionService:
	- cotizar:  De manera general hace una cotización para un solo plan.
		De lo mas relevante que hace son dos cosas:
		1. Este constructor 'BasicHttpsBinding_ICalculoAguilaStub()' se conecta a una URL 
		(con extensión .svc) y configura un stub, que es un cliente SOAP generado automáticamente. 		Este stub te permite invocar métodos del servicio SOAP remoto como si fueran funciones 			locales en Kotlin o Java.
		2. El objeto llamado 'calculo' es un objeto que contiene al atributo '_any' el cual es 
		un arreglo de objetos XML 
	- cotizarAll: Al parecer hace la misma cotización (en el sentido de que usa el mismo servicio de 		cotizacion) pero usa otro tipo de clase para instanciar el objeto de la respuesta en 			comparación con el que utilizar el método cotizar. Esto sucede porque a pesar de que se
		usa el servicio una sola vez, aquí se arma una cotizacion para tres planes: Amplia, 			AmpliaBásica y Cobertura100
		Cotizar all usa la clase ResponseAll() y cotizar usa la clase Response.


repositories -----------------------------------------------------

Todo normal, puras consultas. Pero hay algunas consultas medio insanas.


models -----------------------------------------------------

Todo normal, aunque hay varias anotaciones JsonProperty de mas.


CUALQUIER PROYECTO


Primero me enseñaron a usar los endpoints de la aseguradora.
Después replique ese consumo por mi cuenta por mi cuenta.

Después ya revise flujo por flujo los endpoint's, comenzando por los endpoints.
Anote por cada paquete y cada clase, que hace cada método dentro de él. ESto con la finalidad de que no 
se me olvide anotar el comportamiento de cada método.

Después me enseñaron a usar los endpoints resultantes.
Replicarlo por mi cuenta.


/////////////////////////////////////////////GNP//////////////////////////////////////////////////

VIDEO GNP

El proyecto tiene catalogos, cotiza, emite y cobra.
Solo esta el negocio de ahorra y no de go.

Tiene autos, tractocamione y chofer.

El endpoint issueFull respondera la emisión, numero de póliza y un pdf. 

lógica del pago: viene en paymentService.

Endpoint validCard: valida que sea una tarjeta existente. 
	Devuelve los datos mas relevantes de una tarjeta. Lo importate de esto es que devolverá 
	el numero de la tarjeta encriptado, este valor se meterá en el request de pago. 

Endpoint MSI: Devuelve las formas de pago que puede utilizar cierta tarjeta.

Endpoint valideCard: payment.
	- objeto pago: necesita los datos: nombre del cliente, los datos que devuelven los 
		endpoint's validCard y MSI (la clave, no la descripcion).



CORE GNP (PROYECTO VIEJITO)


Controllers/Autos/ahorra/Particular ---------------------------------------

Nuevamente esta dividido por tipo de vehiculo: partituclar y pick up.

°°°°°° PagoController °°°°°°

Tdoso estos no consumen una capa de service, todo esta aquí en los controllers, si ha dado caso 
se llama a un repository para guardar los logs.

pago3d: Realiza una emisión de póliza de seguro mediante una conexión a un servicio externo.
	Recibe los datos del seguro en formato JSON.
	Construye un XML con credenciales y número de cotización.
	Se conecta a un servicio externo (SOAP/XML) para procesar la emisión.
	Procesa la respuesta:
		Si es exitosa: extrae el número de póliza y guarda en base de datos.
		Si hay error: captura el mensaje de error y también lo registra.
	Retorna la respuesta con el resultado de la operación (éxito o error).

urlSesionPago: crear una sesión de pago 3D Secure con una pasarela de pagos.
	Recibe una solicitud POST con los datos del seguro y pago.
	Construye un XML con todos los datos necesarios para el procesamiento de pago:
		Datos de la tarjeta (número, CVV, fecha vencimiento, titular)
		Monto y número de meses sin intereses (MSI)
		Datos del cliente (email, teléfono).
	Se comunica con una pasarela de pagos externa usando REST Template.
	Procesa la respuesta:
		Si es exitosa (2xx): extrae el código de autorización y actualiza el seguro
		Si falla: captura el error y registra la transacción fallida

planesPago: Recibe un BIN de tarjeta, consulta un servicio externo que devuelve XML con planes 
	de pago, lo transforma a JSON, extrae los elementos de planes y responde al cliente.

validacionCuentaFinanciera: recibe un objeto con datos de seguro y número de tarjeta, consulta un
	servicio externo para validar la tarjeta y obtener datos del banco, actualiza el objeto seguro 
	con esos datos, y lo devuelve como respuesta.

validateCard: recibe un número de tarjeta, consulta un servicio externo para validar y obtener 
	información de la cuenta/tarjeta, y devuelve esos datos en un objeto CardInfo.
	
checkMSI: recibe el BIN de una tarjeta, consulta un servicio externo para verificar los planes de meses
	sin intereses disponibles, y devuelve esa lista (o vacío si falla).


°°°°°° CatalogosAutosController °°°°°°

Intentan hacer que las consultas se guarden como en cache.
Nunca se llama a la capa de servicio si no a un repository para hacer consultas a nuestra db.

RequestMapping: Obtiene las marca de los autos.

getModelos: Obtiene los modelos de determinada marca.

getSubMarcas: Obtiene los submarcas de determinada marca y modelo.

getDescripciones: Obtiene los descripciones de determinada marca, modelo y subarca.


Controllers/Autos/ahorra/Uber ---------------------------------------

°°°°°° CotizacionChoferPrivadoControlador °°°°°°

cotizacionGnp: Recibe datos de un cliente y su vehículo, construye una solicitud XML para el sistema
	 de GNP, procesa la respuesta y devuelve una cotización detallada en formato JSON.


Controllers/Autos/general ---------------------------------------

°°°°°° BancosController °°°°°°

No se llama ningún método de la capa de servicio.

bancos: devuelve un json hardcodeado, al parecer el nombre de bancos.

datoBancario: devuelve un json hardcodeado, al parecer es un listado de tipos de cuentas/tarjetas.

°°°°°° ImpresionController °°°°°°

imprimirPoliza: recibe un número de póliza, llama a un servicio externo de impresión con XML, y 
	devuelve la URL del PDF de esa póliza (o error si no existe).

Controllers/Autos/go ---------------------------------------

°°°°°° CotizacionAutosAllGoController °°°°°°

cotizacionGnp:recibe los datos del cliente y vehículo, calcula distintas cotizaciones de seguro GNP, 
	registra el proceso y devuelve la información completa al cliente.
	Hay varios métodos que son llamados aquí y viven en esta misma clase.

°°°°°° CotizacionEmisionGo °°°°°°

nodoCotizacion: Usado para probar el método de 'cotizacionGnp' de la clase 'CotizacionAutosAllGoController'
	pero usando otros datos cambiados intencionamnete para el objeto 'agente'.
	También se usa para probar otro método que vive en esta clase, también se llama 'cotizacionGnp'.
	
°°°°°° PagoControllerGo °°°°°°

pago3d: Tomar la cotización existente (idCotizacion).
	Llamar a un servicio externo para obtener el número de póliza (NUM_POLIZA).
	Guardar logs del request/response y actualizar el objeto seguro con el número de póliza.
	Resumen: solo emisión de póliza, no procesamiento de pagos.

Controllers/Autos/quotation ---------------------------------------

°°°°°° AbstracQuotationController °°°°°°

quotation: Llama al servicio de cotización y mete toda la infromacion relevante en el objeto seguro.


Controllers/catalogs/ ---------------------------------------

°°°°°° CatalogControllerV4 °°°°°°

getMarcasAutos: Dvuelve las marcas de acuerdo al tipo de vehículo: auto, moto u otro. De manera optima
	porque cachea anteriores respuestas.

getModelos: Dvuelve las modelos de acuerdo a la marca y tipo de vehículo: auto, moto u otro. 
	De manera optima porque cachea anteriores respuestas.

getSubMarcas: Por alguna extraña razón llama al método getModels.

getDescripciones: 







/////////////////////////////////////////////TEORIA/////////////////////////////////////////////////////


GLOSARIO

Cotización de seguro vehicular: es el proceso mediante el cual una aseguradora calcula y te informa cuánto te costaría contratar un seguro para tu auto, de acuerdo con ciertos datos que tú proporcionas. Entre estos
datos pueden ser: genero y edad del cliente, marca y modelo del coche, nivel de cobertura (tipo de paquete), etc.

Periodicidad de pago: frecuencia con la que el cliente desea pagar el seguro.

nivel de cobertura: se refiere a qué tanto te protege el seguro y contra qué riesgos. Es decir, cuáles cosas cubre y cuáles no en caso de accidente, robo, daños, etc.
Se puede entender como que cada nivel tiene un paquete de beneficios distinto.

emisión: Es el contrato que se genera una vez que el cliente adquiere el seguro.
	id de la póliza (contrato)
	En la documentación de las aseguradoras viene que hacen primero: 1. si cobran y después generan
	la pliza o 2. si primero generan la póliza y después cobran.

descuentos: varia entre aseguradora.
	En temporada alta suben los descuentos: hot sale, buen fin, etc.

descuadre de precios: Se da en el servicio de cotización.
	El problema normalmente serán las coverturas (Viene mal el precio en determinado paquete)

los comercial: personas de nuestra compañía que consumen nuestros servicios. 
	Ellos mandan las incidencias (los descuadres, el paquete no es ese, fecha invalida, etc).

Derechos, Derechos de póliza ó derechos de emisión: son cargos adicionales fijos aplicados al emitir 
	una póliza de seguro, independientes de la prima.

primaNeta: es el costo puro del seguro, sin impuestos ni cargos.

primaTotal: la suma de todos los conceptos: prima neta + impuestos + derechos + recargos.

MSI: meses sin intereses.

Pasarela de pagos externa es como un proceso de doble autenticación.


ENDPOINTS

PathVariable ------------------------------------

En todos los endpoint de cualquier proyecto donde este {business} se escribe ahorra y es el único posible valor que puede tomar.



Post ---------------------------------------------

En un método post, esto son los posibles valores que se pueden mandar para ciertos atributos:

tipo de valor: Siempre será 'convenido' a menos que la aseguradora indique que cambies el valor.
Periodicidad de pago: anual, semestral, trimestral, mensual, contado.
servicio: 
	particular: para autos normales
	motoApp: para aplicaciones como uber, didi.
	pickup: camionatas (cherokee).

cp: tiene que ser un valor real y existente.
tipo persona: F (hace referencia a persona fisica).
fecha: yyyy-mm-dd
población: va el municipio 



/////////////////////////////////////////////AFIRME/////////////////////////////////////////////////


WS-AFIRME

Primero se paga y después se emite.
Para pagar se usan los endpoints que nos da la aseguradora.

El repositorio llamado 'centralized' en la carpeta 'core-afirme' contiene los ambientes (los application) usados para el proyecto.

La api de la aseguradora es soap.

bancos: tipo de carpeta que acepta, tipo de pago que acepta la tarjeta y los bancos que acepta.

Nadamas concentrarse en lo que diga v4 y relacionado, lo demás es relacionado a la anterior version.

Actualmanete, nadamas cotiza autos individuales.


Endpoints-----------------------------------------------

buscar clientes: sirve para buscar los clientes que han cotizado con base a su rfc.

agente: especie de licencia para que podemos consumir el servicio de la aseguradora.


cuerpo de la cotización ------------------------------------

idTipoPersonas: siempre 1.

fecha vigencia: depende si el paquete es anual, mensual, etc, si es anual seria la fecha actual mas un año.

getListTipoPoliza: devuelve el id de póliza.

zonaCirculacion se debe usar el catalogo de address.

vechiculo: se obtiene de catalago vehiculo.

paquete se saca de getIdPaquete.
	el atrbuto 'idFormaPago' se saca de donde catalogo pagos
	el atributo pctDescuento lo colocamos nosotros de manera maual.

contratante:
	idCiudad y idEstado se sacan de catalogo address.



CODIGO DE WS-AFIRME (FLUJO VIEJO)


Controllers ------------------------------------

CatalogControllerV4:
	- getBrand: Manda a llamar a getIDLineaNegocio (esto podría meterse en un método de service y no
		dejarlo en un controller).
		si el producto es invalido se le retorna al front (esta lógica también debería ir en un 
		método de service)?? pero si es valido se manda a llamar a las marcas con base a ese id 
		de producto
	- getYears: Manda a llamar a getIDLineaNegocio si el producto es invalido se le retorna al front
		pero si es valido se manda a llamar a los modelos (años) con base a ese id de producto
		y la marca.
	- getSubBrands: Este al parecer hace falta pero si esta su service y repository.
	- getVariant: Manda a llamar a getIDLineaNegocio si el producto es invalido se le retorna al front
		pero si es valido se manda a llamar a las variants con base a ese id de producto, la marca,
		modelo y submarca.

CatalogBankController: 
	- saveBanks: 

ExtractionController: 
	- extract: manda a llmar el servicio de extracción.


		
Service ------------------------------------

CatalogServiceV4: 
	- getBrands: coloca manualmente las marcas mas solicitadas, se solicitan de nuestra db todas las
		marcas con base al tipo de vehiculo.
	- getYear: se solicitan de nuestra db todas los modelos (años) con base al tipo de vehiculo y marca.
	- getSubBrands: se solicitan de nuestra db todas las submarcas con base al tipo de vehiculo, marca
		y modelo.
	- getVariant: se solicitan de nuestra db todas las variants con base al tipo de vehiculo, marca
		modelo, submarca y modelo.

ExtractionService:
	- extract: Llama a 'getLineasNegocio', limpia una tabla auxiliar (como una base temporal) y con 
		cade linea de negocio manda a llamar el metodo 'loopBrands'.
		Devuelve una lista de errores cada elemento representa el error que hubo con alguna linea 
		de negocio.
	- loopBrands: Funcion que se ejecuta de forma paralela para obtener las marcas, submarcas y 
		modelos de cada linea de negocio.
		Con base a esta información, se obtienen todas las descripciones (las variants).	
	- loopVariants: Funcion para obtener de forma paralela todas las descriciones de los tipos de
		vehiculo.
		Con cada estilos le quitamos lo que esa después del guion. si hay un error en la consulta
		de estilos se guarda en una lista de errores.
		Manda a llamar la función 'brandHomologate'.
		Guarda cada variant. si hay un error con el guardado se guarda el error en una lista de 
		errores.
	- brandHomologate: función para homologar las marcas. 
	- subBrandHomologate: función para homologar las submarcas. 
			

Services XML ---------------------------------

Todos estos no deberían de ir.

CatalogoAutosXML: 
	- getXMLLineasNegocio: obtiene las líneas de negocio.
	
	

Utils ------------------------------------

UtilsServiceV2:
	- getIDLineaNegocio: Con base al nombre del tipo de producto (tipo de vehiculo) se devuelve un id.
		Esto podría mejorarse metiéndolo en una tabla, esta conformado por el nombre
		del vehiculo y el id (ambos de tipo string)???
	- 

Catalog: Cambio: debería llamarse catalogUtils o algo asi.
	- getLineasNegocio: obtiene Todos las líneas de negocio (tipos de vehiculo disponibles).
	- getMarcas: obtiene todas las marcas de una liena de negocio con base a la claeve de negocio.
	- getSubmarca: obtiene todas las submarcas de cada marca de una liena de negocio con base a la 			claeve de negocio.
	- getModelos: obtiene todas los modelos de cada marca y submarca de una liena de negocio con base a 		la claeve de negocio.

	- getEstilos: Obtiene los estilos de un coche con base al tipo de vehiculo, marca, submarca y 
		modelo



Models ------------------------------------

AfirmeCoreEntity: Se cree será usado para almacenar datos del catalogo.
	Todo para indicar que si, se puede copiar del clupp porque almacena los datos de marcas, modelos
	(años), submarcas.



Enums ---------------------------------------

VehicleType: Contiene los posibles productos.

BusinessType: Contiene los posibles negocios.







CatalogBankController ---------------------------------------------

°°°°°° saveBanks °°°°°°°

Controller: Llama al método de servicio 'saveBanks'.

Service:
	- CatalogBankService:
		- getListBancos: obtiene la lista de bancos permitidos para el pago.
		- saveBanks: Guarda todos los bancos (clave y nombre) en la db.
			Al paracer se uso una inserción personalizada porque es mas rápida y además
			porque no se tiene la entidad bank.

repository:
	- CatalogBankRepository
		- saveBanks: inserción personalizada.
	

°°°°°° getBanks °°°°°°°

Controller: Llama al método de servicio 'getBanks'.

Service:
	- CatalogBankService:
		- getBanks: Llama al método repository para obtenre los bancos.

repository:
	- CatalogBankRepository
		- saveBanks: Devuelve los bancos insertados.


°°°°°° getCard °°°°°°°

Controller: Llama al método de servicio 'getCards'.

Service:
	- CatalogBankService:
		- getCards: Llama al método repository para obtenre las tarjetas.

repository:
	- CatalogBankRepository
		- getCards: Devuelve las tarjetas.


°°°°°° getMsi °°°°°°°

Controller: Llama al método de servicio 'getMSI' reciba el numero de tarjeta por la url.

Service:
	- CatalogBankService:
		- getMSI: Llama al método 'getTokenMidas', utilizando el token se
			piden las formas de pago para la tarjeta con base a la
			tarjeta y el token (llama al método: 'getPromocionesMSIXML'),
			realiza la solicitud (llama al método: 'connect') y crea
			un arreglo de objetos json con cada promoción y clave.
	- TokenServiceV2:
		- getTokenMidas: Solicita un token a midas el cual se nos pide en los 
			request al paracer este cambiara dinámicamente cada vez que 
			se solicite. A su vez, hay dos tipos de tokens que podemos
			pedir: 1. si el negocio es el normal ó internal o 2. si el 
			negocio es go.
	- PagoXML
		- getPromocionesMSIXML: Contiene el esqueleto de un XML.
	- UtilsServiceV2:
		- connect: Envia una solicitud con base a la url y un cuerpo xml 
			que se le es proporcionado y retorna lo que sea que haya 
			respondido.


IssueControllerV4 ---------------------------------------------

°°°°°° issue °°°°°°°

Controller: Llama al método de servicio 'issuePolicy' recibe un cuerpo de solicitud
	(el cual tiene validaciones de jakarta pero sin pasar el objeto 
	bindingResult) y el tipo de negocio y tipo de vehiculo por medio de la 
	url.

service:
	- getIssuePolicy: Se llenan la response con los datos proporcionados en el 
		Request, verifica si el servicio esta disponible (si no lo esta
		lanza una exception con el error), obtiene el token, prepara
		solitud y mételo en un esqueleto de XML (si no se obtuvo éxito
		responde al fron el error), con base al xml manda la solicitud a 
		la api de la aseguradora, valida si nos respondieron con un json,
		(si no es asi, responde un error al fron), llena la response
		con los datos proporcionados por la respuesta de la aseguradora.
		Se verifica que el cobro hay sido exitoso (si no lo fue se 
		llama al método 'getRecibosPoliza' para ver el estado del pago),
		se genera el pdf y se guarda esta accion en los logs.
		- downloadPoliza: verifica si la póliza existe (si existe y 
			esta cancelada se notifica o bien si no existe se 
			notifica), se intenta buscar el documento y con base
			en el se genera la url de pdf (si no se manda 
			error).
			Resumen: genera la url donde esta el pdf de la póliza.
	- PaymentService
		- getRecibosPoliza: se da el formato requerido para la poliza si 
			no tiene los "-", se prepara un XML para solicitar el 
			recibo de póliza, manda la solicitud (si el recibo esta
			vacio o hay un error, se manda un error al front), con 
			la respuesta se determina si el estatus de pago y 
			respuesta ahorra tiene cierto valor eso significara
			que el pago esta siendo procesado.
			Resumen: checa el estado del pago.

°°°°°° print-policy °°°°°°°


Controller: Llama al método de servicio 'downloadPoliza' recibe un cuerpo de solicitud
	(el cual tiene validaciones de jakarta pero sin pasar el objeto 
	bindingResult) y el tipo de negocio y tipo de vehiculo por medio de la 
	url.
	Resumen: al parecer el propósito de este endpoint sea probar el funcionamiento
	de el método 'downloadPoliza'

°°°°°° dummy °°°°°°°

Controller: Llama al método de servicio 'dummy' recibe un cuerpo de solicitud
	(el cual tiene validaciones de jakarta pero sin pasar el objeto 
	bindingResult) y el tipo de negocio y tipo de vehiculo por medio de la 
	url.

service:
	- IssuePolicyServiceV2
		- dummy: Instancia un objeto de la clase '' y la devuelve.
			Resumen: pareciera ser que solo quieren probar el
			funcionamiento de este método. 


°°°°°° cancel °°°°°°°

Controller: Llama al método de servicio 'cancelarPoliza' recibe el tipo de 
	negocio y id de poliza mediante la url.

service:
	- IssuePolicyServiceV2
		- cancelarPoliza: Obtiene el token, se obtiene la fecha de 
			inicio de la póliza, se prepara el XML para cancelar
			y se envia el XML.
			Resumen: cancela la póliza. Pero extrañamente no se
			usa en ningún lado.
	

PaymentController ---------------------------------------------

°°°°°° getBanks °°°°°°°

Controller: Llama al método de servicio 'getBanks' (renombrado a 
	getextractBankList).

Service:
	- getextractBankList: Consulta la api de la aseguradora y devuelve
		todos los bancos que se pueden pagar.
	

°°°°°° getPaymentStatus °°°°°°°

Controller: Llama al método de servicio 'getRecibosPoliza' recibe el tipo de 
	negocio, id de póliza y el tipo de vehiculo mediante la url.

Service:
	- PaymentService
		- getRecibosPoliza: Usado para probar este método.


QuoteControllerV4 ---------------------------------------------

°°°°°° cotizacionDummy °°°°°°°

Controller: Llama al método de servicio 'dummy' recibe un cuerpo de solicitud
	el tipo de vehiculo y el tipo de negocio en la url.

Service:
	- nombreServicio:
		- dummy: Solo crea la instancia de un objeto.
			Resumen: parace que solo quieren probar crear objetos
			con una clase.


°°°°°° cotizacion °°°°°°°

Controller: Llama al método de servicio 'getIDLineaNegocio' para conocer el id del tipo de vehiculo,
	si el objeto de solicitud solicita todos los paquetes se llama a 'quoteAll' si no se cotiza 
	un paquete en especifico llamando a 'quote'. 
	Recibe un cuerpo de solicitud, el tipo de vehiculo y el tipo de negocio en la url.
	Resumen: cotiza todos los paquetes o uno en especifico.

Service:
	QuoteService:
		- quote: 
			Resumen: hace la cotización de un paquete en especifico.






REESTRUCTURACION

Conocer el flujo del código.

crear mi rama
cambiar en el application.properties el perfil de prod a dev.

Meter los XML en resources.
Orgnaizar las carpetas bien.
todas los modelos que tienen que ver en una misma clase.
meter lo de las cotizaciones en el mismo servicio.
donde van los enums?

cuidar la estructura pe: un proyecto sin el paquete de pruebas (src/test/kotlin), que en el paquete de
pruebas la clase principal de pruebas se llame como la clase 
principal (NombreClasePrincipalApplicationTests).

Crear el swagger.yaml


ACCIONES CUANDO SE TERMINO LA RESTRUCTURACION DE AFIRME

el puerto original era: 5000 pero se cambio a 5001, pero en local era 5001 y se cambio a 5002.

En el application-default.yaml cambiar el perfil a local.
Configurar la propiedad en el application-local que permite crear las tablas (ddl-auto: update).
Después quitar esa configuration por lo delicada que es (ddl-auto: none).
Crear una db local y crear las tablas ahí con el orm de spring boot.
Se probaron los endpoints.

Fue necesario tener toda la tabla y registros de la llamada 'sepomexcat'.
Fue necesario traerse todos los registros de la tabla llamada 'operations'.
Fue necesario traerse la estructura de la tabla llamada 'logscotizacionv2', 'logsPagoV2' y 'logsemisionv2' auque estas ya se tuvieran porque los atrbituos están configurados para no tener limite de longitud en los campos de texto.
Fue necesario tener toda la tabla y registros de la llamada 'tarjetas'.
Fue necesario tener la tabla 'extraccionaux'.


endpoint emisión --------------------------------------

Para probar la emisión: se cotiza y de la respuestas de la cotización se copia desde el objeto vehiculo hacia abajo hasta el objeto cotización (emisión ya no se copia). (se tienen que completar los datos del vehiculo como: placas, noSerie, motor, etc).

Fue necesario agregar placas, noSerie (sacado de https://randomvin.com/), se ajusto el numero de tarjeta
y msi para esa tarjeta.


/////////////////////////////////////////////////////////////////////////////////////////////////////

PRUEBAS

Primero en local se apunta a local.
Después en local se apunta a dev.
Se sube a dev.
Después se apunta a dev.
Después se apunta a prod.


PROBLMAS

Sabemos que un request esta mal si en el response el atributo aseguradora no contiene valor o si 
el aributo codigoErro contiene valor.

La respuesta debe contener:
	El objeto cliente dbe contener almenos su fecha de nacimiento, edad y genero
	El objeto del vechiculo debe contener al menos los mismos datos que enviamos en el request.
	Se debe tener lleno el arreglo de coberturas
	Se debe tener cotización: precios.


