///////////////////////////////////////////////BASICO////////////////////////////////////////////////////

Lenguaje de programación moderno que corre sobre la máquina virtual de Java (JVM). 

Kotlin no usa ;.

val nombreVariable = valor -> Define una variable inmutable (como final en Java).

En Kotlin, cuando se declara una variable var no-nullable, se tiene que inicializar inmediatamente. Entonces algo asi dará error: var apellido: String  *********

lateinit var nombreVariable: tipoDato -> Para poder declarar una variable si haberla inicializado. **

var nombreVariable = valor -> Define una variable mutable (se puede cambiar su valor).
	Kotlin infiere el tipo de dato automáticamente de acuerdo a lo que almacene pero también se puede
	indicar.
	- var nombreVariable: tipoDato = valor -> Define una variable mutable (se puede cambiar su valor)
		indicando el tipo de dato.
	- var nombreVariable: tipoDatoX? -> Para definir una variable que puede almacenar un valor null 
		ó un valor de cierto tipo de dato.
		De esta manera, se evitan los nullPointerException que ocurren en java.

const val NOMBRE_VARIABLE = valor -> Define una constante. Como static final en Java.
	No se declaran dentro de una función o método. *****


TIPOS DE DATO

Solo hay un tipo de dato primito diferente en kotlin en comparación con java.

Kotlin	Descripción	Equivalente Java
Int	Entero (32 bits)	Integer


CASTEO AUTOMATICO

No necesitas hacer cast explícito después de una verificación de tipo de dato.

if (obj is tipoDatoX) {
    // No se necesita convertir a obj al tipo de dato equis)
    // Ya se puede usar obj como si fuera el tipo de dato equis
}


MODOS DE ACCESO

Los modos de acceso son y funcionan igual que en java, salvo por tres excepciones.

En Kotlin no existe el modificador de acceso defaul
En Kotlin, si no pones ningún modificador, es public por defecto.
Existe un modificador de acceso mas, llamado internal el cual sirve para ser Visible solo dentro del mismo módulo (por ejemplo, en el mismo proyecto).


CICLOS

for (i in valorInicial..valorFinal) {
    // N instrucciones
} -> Crea un ciclo que va del valor inicial al valor final de uno en uno.

for (i in valorInicial until valorFinal) {
    // N instrucciones
} -> Crea un ciclo que va del valor inicial el valor (final-1) de uno en uno.

for (i in valorFinal downTo valorInicial) {
    // N instrucciones
} -> Crea un ciclo que va del valor final al valor inicial de uno en uno.

for (i in valorInicial..valorFinal step valorStep) {
    // N instrucciones
} -> Crea un ciclo que va del valor final al valor inicial de step en step.


ESTRUCTURAS DE CONTROL

val newVariable = when (nombreVariableEntrada) {
    valorEntrada1 -> valor1
    valorEntrada2 -> valor2
    valorEntradaN -> valorN
    else -> valorDefault
} -> Hace lo mismo que un switch case de otros lenguajes. Si la variable contiene el valor de entrada 1,
	entonces devuelve el valor 1, si la variable contiene el valor de entrada 2, entonces devuelve el 
	valor 2 y asi sucesivamente.


CONDICIONES

val nombreVariable = if ( condición ) {
    // n intrucciones en caso true
    *devolver un valor*
} else {
    // n intrucciones en caso true
   *devolver un valor*
} -> Kotlin permite usar if-else como una expresión que devuelve un valor, asi la condicion sea verdadera
	o false, la variable tendra un valor. 


FUNCIONES

Existe el tipo de dato para retorno llamado Unit, este indica que no devuelve nada (Unit es como void en Java, aunque también se puede omitirlo).

fun nombreFuncionX(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoRetorno {
    // N instrucciones
}

fun saludar(nombre: String = "amigo") {
    println("Hola, $nombre")
} -> Ejemeplo de función con valor por defecto para un parámetro.


COLECCIONES

List ----------------------------------

Son listas inmutables.

listOf() -> Crea una lista no mutable, equivalente en Java a List.of(...).

setOf() -> Crea una lista no mutable, equivalente en Java a Set.of(...).



MutableList ----------------------------------

Son listas mutables, es decir, que se puede modificar su contenido.

mutableListOf() -> Crea una lista mutable vacía, equivalente en Java a new ArrayList<>().

mutableSetOf() -> Crea una lista mutable vacía, equivalente en Java a new HashSet<>() (no guarda un orden).


Mapas ---------------

val errors = mutableMapOf<String, String>() -> Crea un mapa mutable vacio.
	
errors["nombreLlave"] = valor -> Agrega determinada llave y valor.
	Equivalente al método put.

 val errors = mapOf(
        "nombreLlave1" to valor1,
        "nombreLlave2" to valor2,
	"nombreLlaveN" to valorN
    ) -> Crea e inicializa un mapa inmutable.


EXCEPCIONES

Kotlin no tiene checked exceptions, por lo tanto no estás forzado a usar try-catch o throws para muchas operaciones. Sin embargo, Lo mejor será usar trycatch par

Ejemplo

fun leerArchivo() {
    val contenido = File("archivo.txt").readText() // sin throws
}


OPERADORES

expresión ?: valor -> Operador Elvis. Sirve para proporcionar un valor por defecto cuando una expresión 
	es null.
	Siempre a la varialbes a las que se les aplica la expresión se definen de tal manera que permita
	nulos ********
	
Ejemplo 1:

val nombre: String? = null
val mostrar = nombre ?: "Desconocido"

Ejemplo 2:

val lista: List<Int>? = null
val total = lista?.sum() ?: 0

val nombreVariable: String? = null
nombreVariable?.nombrePropiedad -> Operador de llamada segura. Evita verificar si un objeto es nulo. Si 
	el objeto es null, retorna null (sin lanzar NullPointerException).
	El operador ?. necesita estar antes de una llamada o acceso a una propiedad o función, 	como .length, .toUpperCase(), etc. *****
	Siempre a la varialbes a las que se les aplica la expresión se definen de tal manera que permita
	nulos ********
	Otra manera de verlo es que si de la expresión 'nombreVariable?.nombrePropiedad' la variable
	tiene valor, si podrá usar cierta propiedad. ******

val nombreVariable: String? = null
nombreVariable!!.nombrePropiedad -> Operador de aserción no nula. Se aplica a variables que estamos 
	completamente seguros que NO serán null, pero si lo son se lanzara un NullPointerException.
	El operador necesita estar antes de una llamada o acceso a una propiedad o función, 	como .length, .toUpperCase(), etc. *****
	Siempre a la varialbes a las que se les aplica la expresión se definen de tal manera que permita
	nulos ********
	
a == b -> Compara contenido (como equals en Java). *****

a === b -> Compara referencia (como == en Java). ******




PARA PREGUNTAR DESPUES

Operadores let, run, apply, also, with (scoping functions).

fatory methods

singleton


/////////////////////////////////////////////PATRONES DE DISEÑO////////////////////////////////////////////

FACTORY METHOD

Es un patron de diseño creacional en el cual se definen un conjunto de funciones las cuales ofrecen diferentes formas de crear instancias de una misma clase.
Cada una de estas funciones encapsulan lógica en el momento de crear de objetos y permite construir instancias de una clase evitando el uso directo de constructores.
Sirve para Ocultar lógica compleja de creación y Validar o transformar datos antes de crear el objeto.

class NombreClase private constructor(var atributo1: tipoDato, 
	var atributo2: tipoDato2, var atributoN: tipoDatoN) {} -> Se debe obligar a que la clase no 
		instancie los objetos, esto solo debe ser posible con los métodos de
		fabricas asi que se hace algo asi.
		Al ser un constructor privado es posible usarlo dentro de la misma clase.

companion object {

        fun crearAtributo(pars: tipoDato): NombreClaseX {
	    // lógica para validar o transformar antes de crear
            return NombreClaseX(...) // Siempre la ultima linea llama al constructor privado
        }
} -> Manera de definir multiples métodos de fabrica.
	La instrucción companion object { ... } se usa para declarar métodos de clase y no de instancia.

Cada método de fabrica debe tener nombres semánticos que explican qué se esta creando (pe crear con base a un atributo o crear con base a un posible catalogo de valores que puede tener un atributo (pe si se tiene el atributo rol donde los posibles valores son admin, user, invitado, los métodos se podrían lamar: crearAdmin, crearUser, crearInvitado))*******




//////////////////////////////////////////////////POO///////////////////////////////////////////////////


val nombreObjetoX = nombreClaseX().apply {
    nombreAtributo1 = valor1
    nombreAtributo2 = valor2
    nombreAtributoN = valorN
} -> Sive para setear valores a multiples atributos de un objeto.
	Seria equivalente en java a:
		NombreClaseX objetoX = nombreClaseX();
		objetoX.setNombreAtributo1(valor1);
		objetoX.setNombreAtributo2(valor2);
		objetoX.setNombreAtributoN(valorN);


CONSTRUCTORES

Se tienen dos tipos de constructores: primario y secundario.
El primario se define en la definición de clase.

class NombreClase(var nombreAtributo1: tipoDato, var nombreAtributo2: tipoDato2, 
	var nombreAtributoN: tipoDatoN) -> Constructor en la definición de clase.

class NombreClase(var nombreAtributo1: tipoDato = valor1, var nombreAtributo2: tipoDato2 = valo2, 
	var nombreAtributoN: tipoDatoN) -> Constructor en la definición de clase indicando que hay valor 		por defecto.
		Se puede poner valores por defecto solo a algunos parámetros y no a todos.
		Cuando se define asi el constructor primario, pierde mucho el sentido definir 
		constructores secundarios.
		

Constructor secundario cuando NO existe el primario ----------------------------

Cuando no se define el constructor primario cada constructor secundario debe inicializar absolutamente
todos los atributos

constructor(nombreAtributo1: tipoDato, nombreAtributo2: tipoDato2, nombreAtributoN: tipoDatoN) {
    this.nombreAtributo1 = nombreAtributo1
    this.nombreAtributo2 = nombreAtributo2
    this.nombreAtributoN = nombreAtributoN
} -> Para definir un constructor secundario.
	Ya no se coloca var ni val en el constructor secundario. *******

Constructor secundario cuando existe el primario ----------------------------

Cuando se tiene el constructor primario, dentro de un constructor secundario lo primero en ejecutarse es
la llamada al constructor primario. ****
Entonces la llamada al constructor primario implica que siempre se debe cubrir sus parámetros.

constructor(nombreAtributo1: tipoDato, nombreAtributo2: tipoDato2, 
	nombreAtributoR: tipoDatoR): this(valor1, valor2, valorN) {
    this.nombreAtributo1 = nombreAtributo1
    this.nombreAtributo2 = nombreAtributo2
    this.nombreAtributoN = nombreAtributoN
} -> Para definir un constructor secundario.
	La parte de ': this(valor1, valor2, valorN)' significa la llamada y paso de valores al constructor 
	primario.
	En un constructor secundario, puedes tener cualquier cantidad de parámetros. Lo importante es que 	la llamada : this(...) debe cumplir con todos los parámetros requeridos por el constructor 	primario. ********

Parámetros adicionales en constructor secundario -----------------------------

Si en un constructor primario se definieron N parámetros, un constructor secundario puede definir mas
de N parámetros. Sin embargo, los parámetros adicionales (es decir, aquellos que no corresponden a una propiedad de la clase) no tendrán getter ni setter.

Ejemplo:
class Usuario(val nombre: String, val edad: Int) {
    constructor(nombre: String, edad: Int, correo: String): this(nombre, edad) {
        // correo no existe como propiedad
    }
} -> Si se instancia asi val u = Usuario("Luis", 25, "luis@mail.com"), el objeto 'u' no podrá usar
	su setter ni getter porque correo no se declaró como propiedad en la clase.
	
Si no se tiene constructor primario, cada atributo se debe definir en la clase y aquellos constructores
secundarios que tengan atributos distintos a los definidos en la clase no podrán usar su respectivo 
setter ni getter.

Ejemplo:
class Usuario {
    var nombre: String
    var edad: Int

    constructor(nombre: String, edad: Int, correo: String) {
        this.nombre = nombre
        this.edad = edad
        // correo no existe como propiedad
    }
} -> Si se instancia asi val u = Usuario("Luis", 25, "luis@mail.com"), el objeto 'u' no podrá usar
	su setter ni getter.


bloque init ----------------------------------------------------------

Este bloque siempre se ejecuta después de todos los constructores que se tengan definidos.
Si se tiene mas de un bloque init, todos se ejecutaran después de todos los constructores que se tengan definidos en el orden en el que están definidos (de arriba a abajo).

Queda incluso este tema, para investigar después.


DOBLE Y TRIPLE

Triple(varlor1, valor2, valor3) -> Crea un objeto que contiene tres elementos (una tupla de tres valores).
	Es una forma sencilla de agrupar tres valores relacionados sin necesidad de crear una clase 	
	específica.
	Inmutable: Una vez creado, no se pueden modificar sus valores.
	Genérico: Puede contener valores de cualquier tipo (Triple<A, B, C>).
	Para acceder a los elementos se usa:
		.first: primer valor.
		.second: segundo valor.
		.third: tercer valor.
	o se puede hacer destructuring (como en js).

También existe Pair<a, b> y es completamente análogo.


///////////////////////////////////////////////STRINGS///////////////////////////////////////////////////


cadena.substringBefore("cadenaBuscar") -> Se queda con todo lo que este antes de la primera vez 
	que aparezca la cadena 'cadenaBuscar'.

cadena.substringBeforeLast("cadenaBuscar") -> Se queda con todo lo que este antes de la utlima vez 
	que aparezca la cadena 'cadenaBuscar'.
	Ejemplo:
	val texto = "nombre::apellido::edad"
	val resultado = texto.substringBeforeLast("::")
	println(resultado) // nombre::apellido

cadena.substringAfter("cadenaBuscar") -> Se queda con todo lo que este despues de la primera vez 
	que aparezca la cadena 'cadenaBuscar'.

cadena.substringAfterLast("cadenaBuscar") -> Se queda con todo lo que este despues de la ultima vez 
	que aparezca la cadena 'cadenaBuscar'.



///////////////////////////////////////////////AVANZADO////////////////////////////////////////////////////

CORRUTIANAS

Son una característica propia de Kotlin, diseñadas para facilitar la programación asíncrona y concurrente de forma ligera y estructurada. En Java puro, no existen corrutinas nativas.

Es una forma ligera y eficiente de hacer varias cosas al mismo tiempo (concurrencia), sin necesidad de crear hilos pesados.
Es como una mini tarea o subproceso que puedes pausar y reanudar sin bloquear todo el programa.

Son mucho más livianas que los hilos (Thread), mientras que un cuando se crea un hilo el SO necesita 
reservar 512 KB - 1 MB, una corrutiana es administrada por java o kotlin y solo necesita reservar aprox
1 kb.
Puedes lanzar miles de corrutinas sin colapsar tu app.

val corrutinas = mutableListOf<Deferred<T>>() -> Crea una lista mutable vacía que solo acepta elementos
	de tipo Deferred<T>.
	Cuando se lanza una corrutina con el método async, el resultado que obtienes es un objeto de 
	tipo Deferred<T>, donde T es el tipo de dato que devuelve la corrutina cuando termina.
	Entonces esta linea de código srive para almacenar lo que devuelve cada corrutina, se hace de esta
	manera por lo mismo que las corrutinas se ejecutan en paralelo.

val scope = CoroutineScope( tipoJob + tipoDispatch ) -> Crea una corrutina.
	- tipo de jobs:
		- Job() -> Si una corrutina falla, todas las demás se cancelan.
		- SupervisorJob() -> Permite ejecutar multiples corrutinas en paralelo y si una falla se 
			lanzara una exception pero las otras continúan ejecutándose.
			Se usa cuando las tareas no dependen entre sí.
	- tipo de dispatch: controla en qué hilos corren las corrutinas.
		- Dispatchers.Default: Ideal para tareas como procesamiento de datos, cálculos, 
			lógica empresarial y lo que no requiere acceso a disco.
		- Dispatchers.IO: Para tareas de entrada/salida (I/O): lectura de archivos, llamadas de 
			red, acceso a base de datos, etc.

scope.async { ... } -> Lanza un corrutina
	Dentro de las llaves va el bloque de código que se ejecutará de forma paralela.
	Este metodo siempre devuelve un Deferred<T>, asi que aunque el bloque de codigo no retorne nada,
	en si esta retornando un Deferred<Unit> (Unit == void). *****
	- corrutinas.add(scope.async { ... }) -> Si se lanzan multiples corrutinas estas se deben almacenar
		en una lista especial (de tipo Deferred<T>), porque esta lista nos ayuda a saber
		cuando todas las corrutinas ha terminado.

runBlocking { threads.awaitAll() } -> Espera a que terminen las corrutinas para continuar.
	El bloque runBlocking { ... } bloquea el hilo actual (no cada corrutina, si no el hilo actual) 	además permite usar funciones de tipo suspend.
	La instrucción threads.awaitAll() indica: No continúes hasta que todas las corrutinas de esta 
	lista hayan terminado. Esta función es de tipo suspend.

Si ocurre una excepción dentro del async, no se lanza en ese momento.
Se retiene internamente dentro del Deferred (lo que devuelve), y solo se lanza cuando llamas al metodo
await. 
Con awaitAll recorre cada elemento dentro de la lista especial y les aplica await, si varias corrutinas fallan awaitAll() lanza solo la primera excepción que encuentra. Las otras excepciones de corrutinas que también fallaron, se pierden, a menos que tú manejes cada await() individualmente.




