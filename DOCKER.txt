redes --------------------------------------

docker network inspect nombreRed -> Muestra información de cierta red.
	De los mas importante que se puede ver aqui, es que se puede ver el nombre de todos los
	contenedores que están en esta red.



DOCKERIZAR LA BASE DE DATOS  

redis ------------------------------------

Buscar en docker hub, la imagen oficial de redis.

docker pull redis:alpine3.22 -> Baja la imagen de redis.

docker run -d -p puertoLocal:6379 --name nombreContainer --network nombreRed 
	nombreImagenRedis:nombreTag -> Crea un contenedor a partir de cierta imagen de 
		redis, le asigna un nombre al contenedor, indica el puerto interno en el 
		que trabaja redis (6379), indica el puerto en nuestra maquina local, 
		corre el contenedor en segundo plano y le asigna una red.

Redis es nativo de Linux, al momento no hay manera de instalar una interfaz grafica en Windows
que nos permita conectarnos e interactuar con la db de redis.
Sin embargo hay varias maneras de interactuar con la db.
	1. Entrando al contenedor.
	2. Usando el cliente de redis llamado redis cli (solo disponible en Linux y mac)
	3. Hacer un programa que interactue con la db.

docker exec -it nombreContainer redis-cli -> Para conectarse al cliente de redis.


Mysql ------------------------------------

Desde el mysql workbench de nuestra maquina local, podemos agregar un nueva conxion y 
conectarnos al mysql de ese contenedor. 
En hostname se debe poner el localhost.
En el puerto será el puerto que expone al contenedor (del comando run, el valor de: puertoLocal).




DOCKER COMPOSE

Instrucciones dentro del docker-compose.yaml --------------------

		- environment: 
			Configuraciones para esta opcion:				
			- NOMBRE_VAR_AMBIENTE_1: valor1
			- NOMBRE_VAR_AMBIENTE_2: valor2
			- NOMBRE_VAR_AMBIENTE_N: valorN	-> Para especificar que variables de
				ambiente se ocupara y que valor se les asignara. 
				Esta forma se suele utilizar para configurar los valores de
				las variables de ambiente que ya vienen integradas en la 
				imagen pe cuando el contenedor contendra una db y hay que 
				configurar username, dbname y el password. *****
				- NOMBRE_VAR_AMBIENTE_N: ${NOMBRE_VAR_AMBIENTE_N} -> Manera de 
					inyectar un valor de una variable de ambiente proveniente
					del archivo .env.
					En si, esta forma se puede utilizar en cualquier parte del
					Docker compose, sin embargo, es mas usual ocuparla aquí.
					NO es necesario indicarle a Docker Compose la existencia del 
					archivo .env porque Docker compose por defecto busca el 
					archivo .env con el nombre .env en la misma ruta donde se 
					encuentra el Docker compose.
					
Comandos para el docker-compose.yaml --------------------

docker-compose up -> Corre el archivo docker compose.
	El archivo debe estar en nuestra ruta actual.
	- -d -> Para correrlo en segundo plano.
	- --build -> Para forzar que los build dentro del docker compose se reconstruyan
		aunque estos ya existan.
		Esto se usa cuando se hace un cambio en el docker file o en la app y por
		tanto necesitamos que se reconstruya la imagen definida en el 
		dockerfile. ********
	- --env-file nombreArchivo.env -> Si no se usa esta opción, este comando por defecto buscara
		un archivo llamado .env en la misma ruta que el archivo Docker-compose.yaml y lo 
		cargara para poder usar sus variables dentro del mismo Docker compose.
		Esto se usa para tener diferentes archivos .env, pe uno por cada ambiente. *****







Hacer que un contenedor se conecte con la db de otro contenedor --------------------

°°°°°°°°°°°° Spring boot °°°°°°°°°°°°

Se debera cambiar el nombre del host en la propiedad que contiene la url de conexion con el 
gestor de base de datos al nombre de contendor el cual contiene el gestor de base de datos
de interes.

|||||| Caso: La db esta en un contenedor que usa mysql |||||||

*En aplication.properties*
spring.datasource.url=jdbc:nombreDbrms://hostName:puertoContenedor/nombreDb ->
	En este momento, el hostname puede valer 'localhost' ó 'host.docker.internal', se
	debe cambiar por 'nombreContenedorDbrms', todos los demas valores de esta cadena
	se dejan como esten en se momento.



Persistencia de los datos en el contenedor --------------------

- -v nombreVolumen:rutaGuardado -> Para que el contenedor use cierto volumen y 
		respalde los datos de determinada ruta.
		La 'rutaGuardado' es una ruta dentro del contenedor el cual contiene
		lo que queremos almacenar en el volumen.
		- /var/lib/mysql -> Ruta donde se encuentran las db's que almacena mysql.
		- /var/lib/postgresql/data -> Ruta donde se encuentran las db's que 
			almacena postgresql.
		- /data/db -> Ruta donde se encuentran las db's que almacena mongoDb.
		- /data -> Ruta donde se encuentran las db's que almacena redis.






Optimizacion de dockerfile ------------------------------------

°°°°°° Microservicios con spring boot °°°°°°°°°°

Sirve para optimizar el docker file en tiempo y ejecucion.
En este escenario se supone que se creo microservicios con la forma modular y que el contexto
(el que se define con el comando build) se definio en la raiz del proyecto principal.

Se recuerda que cada mircroservicio debe tener su propio Docker file pero que todos los
microservicios comparten el mismo Docker compose. ***






DOCKER COMPOSE

Instrucciones dentro del docker-compose.yaml --------------------

		Configuraciones que solo usan los contenedores con partes de la app --------
		°°°°°°°° cuando se necesita esperar a otro contenedor que 
			almacena otra parte de la app °°°°°°°°°°°°
		*En el servicio que va a esperar*
		- depends_on:
      		      - nombre-servicio: -> Para indicar que se debe esperar a que se levante
				otro contenedor para levantar este contenedor.
				Observese que a esta opción no lleva '-'.
				- condition: tipoContion:
					Configuraciones para esta opcion:
					- service_started (por defecto) - Solo espera que el 							contenedor exista.
					- service_healthy - Espera a que el test dentro de 							healthcheck pase.
		*En el servicio que debe estar levantado antes*
		- healthcheck: 
			Configuraciones para esta opción:
			- disable: false -> ACTIVA el healthcheck.
			- test: [comando] -> Comando que verifica si el proceso de interés dentro
				del contenedor está saludable (esta listo)
			- interval: ns -> Cada cuánto tiempo se ejecuta el test.
			- timeout: xs -> Tiempo máximo que espera en recibir la respuesta al 
				test.
			- retries: y -> Cuántas veces reintentar el test antes de marcar como 
				"unhealthy".
			- start_period: zs -> Es el tiempo que Docker espera antes de hacer la 
				primera verificación de salud.
			




CREACION DE IMAGENES

Instrucciones dentro de dockerfile --------------------------

FROM nombreImagen:version.x.x.x -> Indica que usaremos cierta imagen.
	- openjdk:versionJdk.x.x.x -> Utilizar cierta imagen con cierta versión de jdk.
		Supuestamente esta deprecated y en su lugar ocupar otras imágenes.
	- eclipse-temurin:17-jdk -> La distribución oficial de OpenJDK creada por la 
		Fundación Eclipse (proyecto Temurin).
		Es una de las más recomendadas para producción.
		Tiene el arranquen de spring boot muy rápido, parcheos muy frecuentes y 
		performance excelente.
		El peso es relativamente grande pero tiene gran estabilidad. **
	- amazoncorretto:17 -> Distribución de OpenJDK mantenida por Amazon, certificada por 
		ellos, optimizada para AWS.
		Ideal para: Apps que corren en AWS, Quienes quieren soporte de Amazon y 			Producción con alta confiabilidad.
		El peso es similar al de temurin, es de arranque rápido.
	- amazoncorretto:17-alpine -> La misma distribución Amazon Corretto, pero montada sobre 
		Alpine Linux, que usa una imagen mas pequeña.
		Performance lento y arranque de la app muy lenta. 
		No se debe usar en proyectos de mircroservicios.

En Linux, todas las aplicaciones necesitan una biblioteca estándar del sistema que implementa funciones como: manejo de memoria, hilos, archivos, sockets (red), DNS, criptografía y
syscalls.
GNU C Library (glibc): Es la versión estándar, completa, rápida***, súper probada y con décadas 
de optimización.
Musl C Library (musl libc): La usa solo Alpine Linux. Es: más liviana, más simple, más segura en
algunos casos, pero menos optimizada y con compatibilidad limitada.
