

Optimizacion de dockerfile ------------------------------------

°°°°°° Microservicios con spring boot °°°°°°°°°°

copy ./pom.xml /app
copy ./nombreMicroservicioX/.mvn ./.mvn
copy ./nombreMicroservicioX/mvnw .
run chmod +x ./mvnw
copy ./nombreMicroservicioX/pom.xml . -> Copia el pom del proyecto principal al espacio de 
	trabajo principal, copia el pom del microservicio al espacio de trabajao del proyecto
	del microservicio y copia todo lo que tiene que ver con maven y su propio wrapper
	al proyecto del microservicio.
	Ademas le da permisos de ejecucion al wrapper por que se puede este permiso al pasar el archivo
	de Windows a Linux.
	
copy ./nombreMicroservicioX/src ./src 
run ./mvnw clean package -DskipTests -> Copia el codigo fuente del microservicio al espacio
	de trabajo del microservicio y genera el jar.
	En VM de Linux, los comandos se ejecutan como: ./nombreComando y en VM de Windows se ejeuctan
	como: .\nombreComando

from nombreImagen:version.x.x.x
workdir /app
copy --from=builder /app/nombreMicroservicioX/target/nombreMicroservicioX-snapshot.jar . ->
	Crea un nueva etapa y define el espacio de trabajo, de la anterior etapa toma
	el .jar y pegalo en el espacio de trabajo de esta otra etapa.

export numPuerto
entrypoint ["java", "-jar", "nombreMicroservicioX-0.0.1-SNAPSHOT.jar"] -> Levanta el jar en el 
	contendor cuando se corra el contenedor.
	Se puede utilizar entrypoint ó cmd, ya dependera si queremos ingresar al contenedor
	o no, considerese que es mas seguro usar entrypoint para que nadie accese al 
	contenedor. ***
	En si, porr defecto Maven genera el nombre del jar como: <artifactId>-<version>.jar. Opcionalmente,
	para personalizar este nombre nos metemos al pom.xml y dentro de la etiqueta build colocamos:
		<finalName>mi-api</finalName>




COMANDOS DE DOCKER 

Imagenes ------------------------------------------

docker image prune -> Eliminar todas las imágenes dangling que no estan asociadas a ningun contenedor.
	Una imagen “dangling” es aquella que no tiene nombre ni etiqueta asociada.
	- docker image prune -a -> Eliminar todas las imágenes dangling que no estan asociadas a 
		ningun contenedor.

docker rmi <idImagen_o_nombreImagen> -> Eliminar una imagen específica que no esta asociada
	a un contenedor.
	Si se usa el nombre de la imagen se debe colocar ':nombreTag' pero si no se coloca se entiende que
	el que se desea eliminar es el que tiene el tag 'latest'. *****
	- docker rmi <idImagen_o_nombreImagen1> <idImagen_o_nombreImagen2> 
		<idImagen_o_nombreImagenN> -> Eliminar varias imágenes a la vez las cuales
			no estan asociadas a ningun contenedor.

Contenedores ---------------------------------------

	- docker ps -s -> Muestra los contenedores en ejecución actual en el sistema Docker con su 
		respectivo RW: tamaño de datos que has escrito en el contenedor y Virtual: tamaño 
		total del contenedor incluyendo la imagen base.

docker restart <nombre_o_id_del_contenedor> -> Para Reiniciar un contenedor que está corriendo.

docker logs nombreContendor_o_idContenedor -> Muestra todos los logs de un contendor hasta
	el momento en que se ejecuta este comando.
	Estos logs, son los mismo que vemos en nuestra terminal cuando levantamos la aplicación
	en nuestro local. *********
	- docker logs -f nombreContendor_o_idContenedor -> Muestra los logs en tiempo real 
		("follow") de un contenedor. Veremos tanto los logs anteriores a nuestra conexión como
		los logs que ocurran después de nuestra conexión. **
		No permite interactuar con el contenedor, asi que si salimos de esta 
		sesion el contenedor no se detendra.

docker attach nombreContendor_o_idContenedor -> Conecta ó engancha nuestra terminal al proceso 
	principal de un contenedor.
	El proceso principal de un contenedor que almacena una app mostrara los logs de la app (entonces 	en este caso, este comando seria igual que haber usado el comando docker logs pero con la 	diferencia de que usar docker logs es nadamas como para ver el proceso principal en modo 
	lectura mientras que con este comando podremos interactuar con el proceso principal, entonces 
	se corre el riesgo de matar el proceso por accidente).
	El proceso principal de un contenedor que almacena una db mostrara los logs de su respectivo 
	demonio.
	En resumen, este comando no es común usuarlo porque puede matar al proceso principal que corre
	dentro del contenedor, y solo se ususaria si es necesario interactuar con dicho proceso. **

docker exec -it nombreContendor_o_idContenedor bash -> Para conectarse al sistema operativo del 
	contenedor y abrir una terminal. 
	En si, Docker exec ejecuta un comando dentro de un contenedor y no reemplaza a algún comando
	como Docker run, entonces con Docker exec no importa si en el Docker file se uso cmd o entrypoint
	al final del archivo, porque con este comando siempre nos podremos conectar al SO del contenedor
	y abrir una terminal.
	- exit -> Para salir de la terminal.

	

redes --------------------------------------

Tipos de redes:
	- bridge: Es el tipo de red normal porque este se usa cuando todos los servicios viven en el
		mismo host y solo se comunican entre ellos. *
	- host: Para que las contenedores estén en la misma red que la maquina host.
	- none: El contenedor o contenedores estarán completamente aislados sin poder
		comunicarse con nadie, es decir, no tendrá acceso a internet ni se podrá comunicar con
		otro contenedor.
	- overlay: crea una red virtual entre múltiples hosts Docker (máquinas distintas).
		Es usado principalmente con Docker Swarm o Docker Compose en modo swarm.
		Los contenedores que estén en la misma red overlay, pueden comunicarse sin importar si
		están en hosts distintos.
	- macvlan: Para que cada contenedor reciba su propia dirección IP y MAC de la red del host.
		Así los contenedores aparecerán en la red local con su propia IP.
		Usado típicamente cuando se necesita que los contenedores sean accesibles como 
		dispositivos reales en tu red (por ejemplo, servidores NAS, impresoras virtuales, 			servicios legacy o IoT).

docker network create nombreRed -> crea una red.
	Una red con Docker te sirve para conectar varios contenedores entre sí de forma 
	segura y controlada, como si estuvieran en la misma red privada.
	Los contenedores se comunican por su nombre.
	Puedes separar entornos (producción, pruebas, desarrollo) en redes distintas.
	Este comportamiento se debe a que por defecto este comando crea una red de tipo bridge. **

docker run -d --name nombreContenedor --network nombreRed -p <PUERTO_HOST>:<PUERTO_CONTENEDOR> 
	idImagen -> Crea y corre un contenedor en segundo plano a partir de una imagen, le asigna 
		un nombre al contenedor y le asigna una red al contenedor.
		Comunmente el nombre del contenedor sera igual al nombre del microservicio.**

*quitar la teoría del tipo de red que viene por ahi*


Persistencia de los datos en el contenedor --------------------

docker run ... -> Con este comando, por defecto Docker crea un volumen anonimo (un volumen sin nombre)
	y se lo asigna al contenedor.
	- -v nombreVolumen:rutaGuardado -> Para que el contenedor use cierto volumen y 
		respalde los datos de determinada ruta.
		La 'rutaGuardado' es una ruta dentro del contenedor el cual contiene
		lo que queremos almacenar en el volumen.
		- /var/lib/mysql -> Ruta donde se encuentran las db's que almacena mysql.
		- /var/lib/postgresql/data -> Ruta donde se encuentran las db's que 
			almacena postgresql.
		- /data/db -> Ruta donde se encuentran las db's que almacena mongoDb.
	El siguiente comando es opcional pero puede ir acompañado con volumenes.
	- --restart=valorOpcion 
		- always -> Si Docker se reinicia (por ejemplo, después de apagar/prender tu 
			PC), el contenedor mi-app se vuelve a iniciar automáticamente.
			Si el contenedor se detiene por error, también se reinicia.
			Si tú mismo lo detienes con docker stop, también se reiniciará 
			automáticamente (a menos que lo elimines con docker rm o cambies su 
			política de restart).
		- no (por defecto) -> No se reinicia nunca automáticamente.
		- on-failure -> Se reinicia solo si el contenedor falla (sale con código 
			distinto de 0).
		- unless-stopped -> Igual que always, pero NO si tú lo detuviste manualmente.

docker system df -v -> Devuelve el Tamaño aproximado de todos los volúmenes, contenedores e 
	imágenes.


DOCKERIZAR LA BASE DE DATOS 

MongoDb ------------------------------------

Buscar en docker hub, la imagen oficial de mongoDb.

docker pull mongodb/mongodb-community-server:7.0-ubi8 -> Baja la imagen de mongoDb.

docker run -d -p puertoLocal:27017 --name nombreContainer --network nombreRed 
	nombreImagenMongoDb:nombreTag -> Crea un contenedor a partir de cierta imagen de mondoDb, le
		asigna un nombre al contenedor, indica el puerto interno en el que trabaja mongoDb 
		(27017), indica el puerto en nuestra maquina local, corre el contenedor en segundo 
		plano y le asigna una red.
	- -e MONGODB_INITDB_ROOT_USERNAME_FILE=username -> Opcional para indicar el nombre de usuario.
	- -e MONGODB_INITDB_ROOT_PASSWORD_FILE=password -> Opcional para indicar el password de usuario.

Desde el mongoDb compass de nuestra maquina local, podemos agregar un nueva conexion y conectarnos al mongoDb de ese contenedor. 
Verifica el puerto de nuestra maquina local que utiliza el contenedor con la db con docker ps.

*En mongoDb compass*
name: asginarle el nombre del contenedor.
Advaced connection options
	- host: localhost:puertoLocal -> El puerto será el puerto local que usamos en el comando 
		para la creación del contenedor (comando anterior).


Hacer que un contenedor se conecte con la db de otro contenedor --------------------


°°°°°°°°°°°° Spring boot °°°°°°°°°°°°

*Caso: mongoDb*
spring.data.mongodb.host=nombreContenedorDb -> En este momento, el hostname puede valer 'localhost' ó
	'host.docker.internal', se debe cambiar por 'nombreContenedorDb', todos los demas valores 
	para la configuracion con la db se dejan como esten en se momento.


POSIBLES ERRORES

Cosas que se revisan ante posibles errores.

1. El Docker no esta iniciado. Verifciar que este corriendo con:
	docker compose version
2. El puerto que expone a la aplicación tiene que tener el mismo valor que el puerto que abrimos del 
contenedor y que exponemos al crear el contendor, es decir, en 3 lugares tiene que haber el mismo valor.
	*application-perfil*		*dockerfile*            *Docker-compose o comando run*
	 server.port=valorX      ->      expose valorX      ->   ports:
     								 - "puertoLocal:valorX"


DOCKER COMPOSE

Instrucciones dentro del docker-compose.yaml --------------------

version: "x.x" -> Indica la version del esquema del formato YAML, no a la versión de Docker en sí.
	Las versiones 2.x ya están obsoletas, las versiones 3.x son antiguas pero aun estables y 
	actualmente lo mas nuevo es ya no especificar ninguna versión porque el formato se define 
	automáticamente.

networks: -> Para crear objetos con configuraciones de red.
	Configuraciones para esta opcion:
	- nombreObjetoRedX: -> Crea un objeto con configuraciones de red.
		Configuraciones para el tipo de red bridge ------------------
		- name: nombreRed -> Para indicar el nombre de esta red.
		- driver: nombreTipoRed -> Para indicar el tipo de red.
		- external: true -> Para decirle a Docker Compose que use una red que ya 
			existe porque seguramente fue creada anteriormente con el comando docker créate
			network.
		- driver_opts:
     			com.docker.network.bridge.enable_ip_masquerade: "false" -> Para Aislar la red (sin 				acceso a Internet).
				Esto deja la red cerrada al exterior, asi que los contenedores se podrán
				comunicar entre si pero no tendrán internet.
			



		- build: -> Equivalente al comando build. Para construir una imagen con base
			al contenido de un docker file.
			Si la imagen ya existe, no la vuelve a crear.
			Configuraciones para esta opcion:
			- context: ruta -> Para indicar al ruta del contexto.
				Se pondria como valor './' para indicar que el contexto es
				la ruta actual del docker compose (el cual esta en la raiz
				del proyecto principal/padre). ***
			- dockerfile: ruta/Dockerfile -> Para indicar la ubicacion y el nombre 
				del dockerfile.


///////////////////////////////////IMPLEMENTACION//////////////////////////////////////////

BACKEND

Spring boot -------------------------------

°°°°°°°°°°°° Con puros comandos °°°°°°°°°°°°


1. Crear una red y corroborar su existencia.
2. Bajar la imagen o imágenes para la db. Corroborar su existencia.
3. Crear el contenedor o contenedores que almacenan la o las db's y meterlas a la red. A cada uno de 
	estos contenedores se le asigna un volumen.
4. Modificar el código fuente del proyecto o proyectos para que se puedan conectar con la db de los
	contenedores.
5. Integrar el dockerfile al proyecto y adecuarla a la arquitectura del proyecto.
6. Correr el Dockerfile con el comando build (crear la imagen). Corroborar su existencia.
7. Crear los contenedores para la app con base a la imagen. Corroborar su existencia.
8. Usando postman probar la app, si algo sale mal meterse a los logs de la app.


