


GIT FLOW

Gestionar ramas de manera más eficiente y Automatiza merge's.
No es una herramienta nueva, sino un método que puedes aplicar usando Git.

main (o master) → Contiene el código estable (versiones finales).
develop → Rama de integración (aquí se juntan las nuevas features antes del release).
feature/* → Ramas para desarrollar nuevas funcionalidades.
release/* → Ramas para preparar una nueva versión.
hotfix/* → Ramas para corregir errores críticos en producción.

git flow init -> Activar el modo Git Flow" en el repositorio.
	Configura en tu repositorio local las reglas y nombres que usará para crear y finalizar ramas.
	Detecta cual es la rama principal, cual es la rama de desarrollo (Si no tienes develop, la crea 
	a partir de main).
	Se definen los prefijos para cada tipo de rama (el texto que se coloca antes del nombre de la 
	rama para indicar su tipo pe feature, realese, etc).
	A todos lo que nos pregunte el comando se le da enter, al finalizar la preguntas nos dejara en 
	la rama develop.
	No importa en que rama nos encontremos, este comando se puede usar, sin embargo si en la rama 
	actual tenemos algo pendiente por darle commit, este comando fallara. ******

ramas feature ---------------------------------------------

git flow feature start nombreRama -> Crea una rama local con el prefijo utilizado (feature en este caso)
	a partir de la rama develop.
	Internamente ejecuta varios comando de git: ejecuta el comando para que nos cambiemos a la rama
	develop (checkout/switch), bajemos lo relacionado a esa rama para tenerla actualizada (pull), crea 	la rama de feature y nos cambia a esta nueva rama (switch).
	El nombre de la rama será un nombre que describa la funcionalidad que se implementara.

git flow feature finish nombreRama -> Fusiona (merge) la rama feature/nombreRama en develop, despues
	Borra la rama feature/nombreRama (localmente) y nos posiciona automáticamente en develop.
	Fallara el comando si hay algo pendiente por hacerle commit en la rama feature.
	Si hay conflictos Git Flow detendrá el proceso y te pedirá resolverlos manualmente (como en un
	merge clásico).
	Se nos manda a vim y debemos escribir el mensaje del commit (sin las comillas dobles envolviendo 
	al string), para eso presionar i (insert) para que nos deje escribir después presionar esc para 	indicar que terminamos de escribir, y escribimos :wq! -> Para guardar y salir de vim. Nos pide el 	commit en vim 2 veces pero solo lo escribimos una vez (el otro nos lo saltamos).
	
En este momento deberemos hacer el git push.


°°°°°°° Deshacer el merge y conservar la rama feature °°°°°°°

Esta teoría solo aplica si aun no se ha dado el push.

git reset --hard HEAD~1 -> Esto elimina el merge commit, dejando develop justo como estaba antes del finish.
	Este comando se ejecuta en la rama develop.

git reflog -> Muestra el historial de acciones.
	La diferencian con git log, es que este comando muestra commits relacionados con ramas o commits que 
	ya fueron eliminados.
	Incluye cosas como: Cambios de rama, Commits que se eliminaron con reset --hard y Merges.

Con este comando buscar el hash anterior*** a algo como:
<hash>  HEAD@{1}: checkout: moving from feature/nombreRama to develop

git checkout -b feature/nombreRama <hash> -> Para recrear cierta rama. 



ramas realese ---------------------------------------------

git pull origin master
git checkout develop
git pull origin develop -> Antes de iniciar un release, siempre se ejecutan estas instrucciones para tener 	la versión más reciente.

git flow release start vx.y.z -> Crea una rama de release llamada release/vx.y.z, Prepara una nueva 
	versión para producción, Permite realizar últimas pruebas y ajustes antes del lanzamiento, 
	Fusiona con main y develop, crea tag
	Nos dejara en la rama de realse que hemos creado.
	Donde de vx.y.z el valor 'x.y.z' es la versión del proyecto. Para saber que numero ponerle uno
	de debe guiar del resultado del comando git tag, pero si no hay tags el valor que se pondrá 
	es: 'v1.0.0'.
	Para cambios pequeños se incrementa en uno a zeta.
	
Cuando terminas el release (git flow release finish vx.y.z), Git Flow hace dos merges automáticos:
release → master
release → develop
Eso significa que todos los cambios que hiciste en la rama release también se aplican en develop. Por lo
que, apuntar a prod en el application.yaml dentro de la rama realese no seria recomendado porque en la 
rama develop se quedaría apuntando a prod y bien podría hacerse el cambio de vovler a apuntar a dev en el
application.yaml pero implicaría hacer otro commit. 

git flow release finish vx.y.z -> Fusiona la rama de release en main (master), Crea un tag con el nombre 
	de la versión, Borra la rama release/vx.y.z localmente.
	Se nos manda a vim y debemos escribir el mensaje del commit (sin las comillas dobles envolviendo 
	al string), para eso presionar i (insert) para que nos deje escribir después presionar esc para 	indicar que terminamos de escribir, y escribimos :wq! -> Para guardar y salir de vim. Nos pide 2 	mensajes: el primero es para el tag (puedes aceptar el predeterminado o personalizarlo) y el 
	segundo es para el tag (este se puede quedar con el valor por default, que seria el que 
	utilizamos al crear el realese (vx.y.z)).

En este momento deberemos apuntar a prod y despues hacer el git push. ***



STASH

git stash -> permite guardar temporalmente cambios que aún no has confirmado (committed) en una pila.
	Cada stash se guarda en una pila, y se identifica con un índice y un mensaje.
	Esto es útil porque se puede:
	- Puede que hayamos escrito código en una rama equivocada, entonces si no hemos hecho commit, 
		podemos aplicar este comando y llevarnos ese código para pegarlo en la rama en la que 
		debería estar.
	- Necesitamos cambiarnos de rama para verificar algo, pero ya hemos escrito código que si va en
		la rama actual pero para poder cambiarnos de rama necesitamos no tener cambios, entonces 		podemos almacenar temporalmente ese código, cambiarnos de rama, regresar a la rama y sacar 		ese codgo.

git stash save "mi cambio temporal" -> Lo mismo que el comando anterior solo que con esta forma podemos
	añadir un mensaje personalizado de lo que hay en ese stash.

git stash list -> muestra todos los stashes que tienes guardados en la pila.
	El índice 0 indica que es el stash mas reciente.
	WIP → “Work In Progress” (trabajo en progreso).
	on main → Rama en la que estabas cuando hiciste el stash.
	9a0b3f2 → Hash corto del commit donde estabas al hacer el stash.
	Después habrá un Mensaje opcional que describe los cambios (si lo proporcionaste al hacer el stash).

git stash show -p -> Compara lo que hay en el stash más reciente con lo que esta en nuestro commit actual.
	Esto se ha usado para saber que hay dentro del ultimo stash, antes de pegarlo en el commit 
	actual. ****
	- git stash show -p stash@{n} ->  Compara lo que hay en determinado stash con lo que esta en nuestro 		commit actual.

git stash pop -> Para sacar lo del stash más reciente, aplicarlo a el commit actual y Eliminar ese stash 
	de la pila de stashes.

git stash apply -> Para sacar lo del stash más reciente, aplicarlo a el commit actual y NO Eliminar ese 	stash de la pila de stashes.
	Útil si quieres aplicar los mismos cambios en múltiples branches.

git stash clear -> Elimina todos los stashes.

git stash drop -> Elimina el stash mas reciente de la pila de stashes.
	- git stash drop stash@{n} -> Elimina determinado stash de la pila de stashes.


TAGS

*eliminar teoría que viene al inicio*
*reestructura la explicacion de ciertos comandos*

Es una etiqueta que se asigna a un commit específico. Sirve para marcar puntos importantes en la historia 
de tu repositorio, como versiones de software (v1.0, v2.1, etc.).

SemVer: Versionado semántico. La convención típica es: 'vMAJOR.MINOR.PATCH'
	- v → Prefijo opcional para indicar "versión" (no es obligatorio, solo costumbre).
	- MAJOR (primer número) → Versión mayor. Se incrementa cuando hay cambios incompatibles.
		Un cambio incompatible es cualquier modificación que hace que el software que dependía de 
		la versión anterior ya no funcione igual sin ajustes.
		Ejemplos de cambios incompatibles en una api:
		- Cambias el nombre de un parámetro obligatorio (customerId → clientId).
		- Cambias el tipo de dato de un campo en la respuesta (date en string → date en timestamp).
	- MINOR (segundo número) → Versión menor.MINOR (segundo número) → Versión menor. Se dan cuando 			agregas nuevas funcionalidades que no rompen lo existente.
		Ejemplos de nuevas funcionalidades en una api:
		- Nuevos endpoints. Pe antes se tenia GET /users/{id} y ahora se agrega GET /users/{id}/pets
			entonces lo usuario pueden seguir usuando el primero endpoint con normalidad pero
			ahora con una funcionalidad extra.
		- Nuevos parámetros opcionales. Pe antes se tenia GET /orders y ahora se agrega 
			GET /orders?status=pending, si uno no status, la API sigue respondiendo bien.
		- Nuevos campos en la respuesta.
	- PATCH (tercer número) → Corrección de errores.
		No cambia nada para el cliente (solo arreglos).

git tag -> Muestra todos las tags que se tienen.
	[opciones]:
	- -a vMAJOR.MINOR.PATCH -m "mensaje" idCommit -> Crea un tag a determinado commit.
	- -a vMAJOR.MINOR.PATCH -m "mensaje" -> Crea un tag al commit en el que estemos 
		posicionados.
	- -a vMAJOR.MINOR.PATCH HEAD~n -m "mensaje" -> Crea un tag a n commits atras.
		Pe si n=2, le crearia el tag al commit que esta dos comiits atras del
		actual.
	- -d nombreTag -> Elimina determinado tag del repositorio local.

git show vMAJOR.MINOR.PATCH -> Muestra informacion de determinado tag: quien hizo el tag, 
	la fecha del tag, el mensaje del tag, el id commit del tag y también el diff 
	del commit (Muestra los cambios de código que introdujo ese commit).

git push origin --tags -> Por defecto, los tags no se suben al remoto cuando haces git push. Este comando
	sirve para subir todos los tags.
	- git push origin vMAJOR.MINOR.PATCH -> Para subir determinado tag.

git push origin --delete tag vMAJOR.MINOR.PATCH -> Elimina determinado tag del repositorio remoto.



