


GIT FLOW

Gestionar ramas de manera más eficiente y Automatiza merge's.
No es una herramienta nueva, sino un método que puedes aplicar usando Git.

main (o master) → Contiene el código estable (versiones finales).
develop → Rama de integración (aquí se juntan las nuevas features antes del release).
feature/* → Ramas para desarrollar nuevas funcionalidades.
release/* → Ramas para preparar una nueva versión.
hotfix/* → Ramas para corregir errores críticos en producción.

git flow init -> Activar el modo Git Flow" en el repositorio.
	Configura en tu repositorio local las reglas y nombres que usará para crear y finalizar ramas.
	Detecta cual es la rama principal, cual es la rama de desarrollo (Si no tienes develop, la crea 
	a partir de main).
	Se definen los prefijos para cada tipo de rama (el texto que se coloca antes del nombre de la 
	rama para indicar su tipo pe feature, realese, etc).
	A todos lo que nos pregunte el comando se le da enter, al finalizar la preguntas nos dejara en 
	la rama develop.
	No importa en que rama nos encontremos, este comando se puede usar, sin embargo si en la rama 
	actual tenemos algo pendiente por darle commit, este comando fallara. ******

ramas feature ---------------------------------------------

git flow feature start nombreRama -> Crea una rama local con el prefijo utilizado (feature en este caso)
	a partir de la rama develop.
	Internamente ejecuta varios comando de git: ejecuta el comando para que nos cambiemos a la rama
	develop (checkout/switch), bajemos lo relacionado a esa rama para tenerla actualizada (pull), crea 	la rama de feature y nos cambia a esta nueva rama (switch).
	El nombre de la rama será un nombre que describa la funcionalidad que se implementara.

git flow feature finish nombreRama -> Fusiona (merge) la rama feature/nombreRama en develop, despues
	Borra la rama feature/nombreRama (localmente) y nos posiciona automáticamente en develop.
	Fallara el comando si hay algo pendiente por hacerle commit en la rama feature.
	Si hay conflictos Git Flow detendrá el proceso y te pedirá resolverlos manualmente (como en un
	merge clásico).
	Se nos manda a vim y debemos escribir el mensaje del commit (sin las comillas dobles envolviendo 
	al string), para eso presionar i (insert) para que nos deje escribir después presionar esc para 	indicar que terminamos de escribir, y escribimos :wq! -> Para guardar y salir de vim. Nos pide el 	commit en vim 2 veces pero solo lo escribimos una vez (el otro nos lo saltamos).
	
En este momento deberemos hacer el git push.


ramas realese ---------------------------------------------

pendiente de investigar a detalle

git flow release start vx.y.z -> Crea una rama de release llamada release/vx.y.z, Prepara una nueva 
	versión para producción, Permite realizar últimas pruebas y ajustes antes del lanzamiento, 
	Fusiona con main y develop, crea tag
	Nos dejara en la rama de realse que hemos creado.
	Donde de vx.y.z el valor 'x.y.z' es la versión del proyecto. Para saber que numero ponerle uno
	de debe guiar del resultado del comando git tag, pero si no hay tags el valor que se pondrá 
	es: 'v1.0.0'.
	Para cambios pequeños se incrementa en uno a zeta.
	
Para proyectos en spring boot, nos dirigimos al application-default, cambiar el perfil a prod y hacer commit.
Antes de ejecutar el siguiente comando, cambiarse a master y hacer pull para tener actualizada esa rama.
Después regresar a nuestro realese y terminarlo. *****

git flow release finish vx.y.z -> Fusiona la rama de release en main (master), Crea un tag con el nombre 
	de la versión, Borra la rama release/vx.y.z localmente.
	Se nos manda a vim y debemos escribir el mensaje del commit (sin las comillas dobles envolviendo 
	al string), para eso presionar i (insert) para que nos deje escribir después presionar esc para 	indicar que terminamos de escribir, y escribimos :wq! -> Para guardar y salir de vim. Nos pide 2 	mensajes: el primero es para el tag (puedes aceptar el predeterminado o personalizarlo) y el 
	segundo es para el tag (este se puede quedar con el valor por default, que seria el que 
	utilizamos al crear el realese (vx.y.z)).

En este momento deberemos hacer el git push.



STASH

git stash show -p -> Compara lo que hay en el stash más reciente con lo que esta en nuestro commit actual.
	Esto se ha usado para saber que hay dentro del ultimo stash, antes de pegarlo en el commit 
	actual. ****+

git stash pop -> Para sacar lo del stash más reciente, aplicarlo a el commit actual y Elimina 	automáticamente ese stash de la lista.

git stash apply -> Para sacar lo del stash más reciente, aplicarlo a el commit actual y NO Elimina 	automáticamente ese stash de la lista.
	Útil si quieres aplicar los mismos cambios en múltiples branches.

git stash clear -> Elimina todos los stashes.


TAGS

*eliminar teoría que viene al inicio*
*reestructura la explicacion de ciertos comandos*

SemVer: Versionado semántico. La convención típica es: 'vMAJOR.MINOR.PATCH'
	- v → Prefijo opcional para indicar "versión" (no es obligatorio, solo costumbre).
	- MAJOR (primer número) → Versión mayor. Se incrementa cuando hay cambios incompatibles.
		Un cambio incompatible es cualquier modificación que hace que el software que dependía de 
		la versión anterior ya no funcione igual sin ajustes.
		Ejemplos de cambios incompatibles en una api:
		- Cambias el nombre de un parámetro obligatorio (customerId → clientId).
		- Cambias el tipo de dato de un campo en la respuesta (date en string → date en timestamp).
	- MINOR (segundo número) → Versión menor.MINOR (segundo número) → Versión menor. Se dan cuando 			agregas nuevas funcionalidades que no rompen lo existente.
		Ejemplos de nuevas funcionalidades en una api:
		- Nuevos endpoints. Pe antes se tenia GET /users/{id} y ahora se agrega GET /users/{id}/pets
			entonces lo usuario pueden seguir usuando el primero endpoint con normalidad pero
			ahora con una funcionalidad extra.
		- Nuevos parámetros opcionales. Pe antes se tenia GET /orders y ahora se agrega 
			GET /orders?status=pending, si uno no status, la API sigue respondiendo bien.
		- Nuevos campos en la respuesta.
	- PATCH (tercer número) → Corrección de errores.
		No cambia nada para el cliente (solo arreglos).






