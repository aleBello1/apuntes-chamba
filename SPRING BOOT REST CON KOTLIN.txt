@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
) ->
	La unica diferencia es que en el atributo id, se usas var porque se genera y se 
	asigna automáticamente cuando guardas el objeto (no tienes que darlo tú).
	Es nullable (Long? = null) porque inicialmente no tiene valor, y solo la base de 
	datos lo asignará.
	Es mutable (var) para que JPA pueda asignar el valor al guardar.

Lo malo de kotlin es que para instanciar objetos de clases entity es necesario pasarle valores a todos
los atributos, incluyendo al id aunque este lo genere automáticamente jpa, lo común es asignarle el 0.
U otra alternativa es usar named arguments, cuando se instancie un objeto se debe especificar a que atributo
va cada valor y en este caso se omitiría el nombre del atributo id.

val objetoX = NombreClaseX(
    nombreAtributo1 = valor1,
    nombreAtributo2 = valor2,
    nombreAtributoN = valorN,
)



///// OTROS ///////////////////////////////////////////////////

CONSULTAS NATIVAS

Es cuando en un método dentro de una clase repositorio hace una consulta personalizada usando la anotación
query y usando sql nativo (la sintaxis de sql y no la jpql).
Hacerlo de esto modo tiene la característica que el resultado será de tipo 'TupleBackedMap' (resultado genérico de una consulta nativa).

Para convertir el resultado de una consulta nativa a un objeto java hay varias formas: 1. si el objeto de 
retorno coincide con un objeto de una clase entity, en este caso spring boot hará la conversión 
automáticamente 2. si el objeto de retorno debe ser un dto, se deben aplicar diversas técnicas.

Convertir el objeto de retorno de una consulta nativa a un dto -----------------------------------

Se debe hacer un mapeo explícito con: @SqlResultSetMapping, @ConstructorResult, proyección de interfaz o constructor expresivo en JPQL.

°°°°°°°° Usando proyección °°°°°°°

Esta forma se usa cuando el dto nunca se necesita para instanciar objetos en todo el proyecto, solo se
ocupara para cachar lo que retornan las consultas nativas.

interface NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
} -> Cambiar la clase dto por una interface.
	Si se define un DTO como interfaz, Spring hace el mapeo por nombre de columnas, entonces las
	queries deben devolver las columnas con los mismos nombres de atributos de la interface dto.


°°°°°°°° Usando proyección + clase dto °°°°°°°

Esta forma se usa cuando el dto se necesita para instanciar objetos en alguna parte del proyecto y mas
aparte se necesita la proyección para cachar lo que retornan las consultas nativas.
 
*se crea la proyección*

data class NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
}

*En un método de servicio*
*Al usar un método repositorio que hace la consulta nativa*
objetoXRepository.nombreMetodoX().map {
        NombreClaseDto(it.nombreAtributo1, it.nombreAtributo2, it.nombreAtributoN)
} -> se debe convertir el resultado a la clase dto.


ENTITY MANAGER
 
Es una alternativa a usar las operaciones que brinda una clase repository que implmenta el Spring Data de jpa.
Se usa en consultas dinámicas donde el nombre de la tabla o campos cambian, porque en las consultas de jpa 
solo se puede cambiar dinámicamente el valor que se le pasan a los campos y no el nombre de tablas o 
campos. ******

Se crea una clase llamada: NombreClaseXRepository y se le inyecta el objeto entityManager.

@Repository
class NombreClaseXRepository(
    @PersistenceContext private val entityManager: EntityManager
) {...} -> Crea una clase y la vuelve un componente de spring boot.
	Inyecta el objeto entityManager el cual sirve para ejecutar consultas JPQL o nativas y Persistir o 
	eliminar entidades.

*Dentro de algun metodo*

val sql = """
            sentencia sql
        """.trimIndent() -> Se crea un string el cual contiene a la operación sql a realizar.

Crear queries ----------------------------------

val query = entityManager.createNativeQuery(sql) -> Crea un objeto Query que representa la consulta
	a realizar (No ejecuta nada todavía).
	La variable sql contiene una operación de sql nativa. ***

val query = entityManager.createQuery(sql, NombreClaseEntidadX::class.java) -> Crea un objeto Query que 	representa la consulta a realizar (No ejecuta nada todavía).
	La variable sql contiene una operación de sql nativa. ***
	El resultado se mapeara automáticamente a entidades JPA.

query.setParameter("paramName", valor) -> Para inyectar valores a nivel (WHERE), SET en UPDATE, INSERT.
	No funciona para inyectar el nombre de tablas. ****
	En la consulta sql iría algo como: ':paramName' y para inyectar ese valor seria con esta 
	instrucción.  
	
Para ejecutar consultas ------------------------

query.getResultList() → Ejecuta la consulta y devuelve una lista de resultados.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.resultList as List<Array<Any>>
	  return result.map {
    		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		)
	  } -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
		el arreglo de filas en una lista de objetos dto.
		- cols[0].toString() -> Esta seria la manera de convertir un campo que contiene un 
			valor diferente de string a string (pe convertir un int, bigInt, etc a string).

query.getSingleResult() → Ejecuta la consulta y devuelve un solo resultado.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.singleResult as Array<Any>
		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		) -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
			la fila en un objeto dto.

query.executeUpdate() → Para insert, update o delete (no devuelve filas).


Se tuvo la situación de que se particiono una tabla mediante la técnica de partición por catálogos, de 
tal modo que se tenia una tabla llamada extracción y contenía datos de todos los vehículos pero había
muchos tipos de vehículos asi que se creo una tabla para cada tipo de vehiculo obteniendo las tablas:
extraccion_auto, extraccion_tractocamion y extracción_pickup. Cada una de estas 3 tablas evidentmente
tenían la misma estructura que la tabla original (tabla extraccion).
Entonces al hacer este cambio las consultas que habían originalmente quedaron totalmente igual pero ahora
había que cambiar dinamicamnete el nombre de la tabla para que apuntara de acuerdo al tipo de camión
buscado. Entonces para eso se uso entity manager.



//////AVANZADO //////

CIFRADO Y DESCIFRADO DE DATOS

Utilizado para cifrar llaves y credenciales, tambien para cifrar tokens.

Teoría ------------------------------------------------------

Initialization Vector (IV): es un valor ALEATORIO que asegura que un mismo texto al ser cifrado con la misma
llave se obtenga siempre un diferente resultado.
Un IV siempre debe ser:
 	ÚNICO: Nunca reusar el mismo IV con la misma clave
	ALEATORIO: Debe ser impredecible (usar SecureRandom).

Tamaño del iv según el algoritmo:
Algoritmo	Tamaño de bloque	Tamaño de IV requerido
AES	        128 bits (16 bytes)	16 bytes
DES	        64 bits (8 bytes)	8 bytes
3DES	       64 bits (8 bytes)	8 bytes
Blowfish	64 bits (8 bytes)	8 bytes

Aes
Longitudes:
Tamaño	       Bits	Intentos para romper	Tiempo estimado
16 bytes	128	2¹²⁸	Billones de años
24 bytes	192	2¹⁹²	Edad del universo
32 bytes	256	2²⁵⁶	Múltiples edades del universo


Flujos --------------------------------------------------

Cifrado:
	Generar IV aleatorio nuevo
	Cifrar texto con clave + IV aleatorio
	Concatenar: IV_aleatorio + texto_cifrado
	Devolver todo en Base64

Descifrar:
	Separar IV y texto cifrado
	Descifrar con clave + IV recibido
	Devolver texto plano
	

Configuraciones -----------------------------------------

Se crea un application llamado: application-secrets. Aquí se depositan la llave que se usa para cifrar y 
descifrar (secretKey) y otras claves y valores sensibles.

*En application-secrets*
 clave1: valor1
 clave2: valor2
 claveN: valorN 

*En application-default*
spring.profiles.include=secrets -> Le dice a Spring que active el perfil "secrets" ADEMÁS de los perfiles
	ya activos.
	De esta manera es como si esta configuraciones se incluyen automáticamente en todos los entornos.


En utils/crypto/ ---------------------------------------

Crear la clase que genera la llave que va en application-secrets.

°°°°°°°°° KeyGeneratorUtil °°°°°°°°°°

// Para poder generar una nueva llave de cifrado cada que asi se necesite
object KeyGeneratorUtil {

    @Throws(Exception::class)
    fun generarClaveSecreta(tamanio: Int): Map<String, String> {
        require(tamanio == 16 || tamanio == 24 || tamanio == 32) {
            "Tamaño debe ser 16, 24 o 32"
        }

        val keyGen = KeyGenerator.getInstance("AES")
        keyGen.init(tamanio * 8)
        val secretKey = keyGen.generateKey()
        val claveBase64 = Base64.getEncoder().encodeToString(secretKey.encoded)

        return mapOf(
            "base64" to claveBase64,
            "string" to String(Base64.getDecoder().decode(claveBase64), Charsets.UTF_8),
            "tamanio" to tamanio.toString(),
            "bits" to (tamanio * 8).toString()
        )
    }

    fun generarLlavesCompletas(tamanioClave: Int = 32): Map<String, Any> {
        val clave = generarClaveSecreta(tamanioClave)

        return mapOf(
            "clave" to clave,
            "yamlConfig" to """
                crypto:
                  secret-key: "${clave["string"]}"
                  algorithm: "AES/CBC/PKCS5Padding"
                  key-algorithm: "AES"
            """.trimIndent()
        )
    }

}

Crear un Controller que llama a la función generarLlavesCompletas() y la llave colocarla en el
application-secrets.
De todos los valores que retorna la función, la llave vendría a ser la correspondiente al atributo base64.

Generar el servicio de cifrado y descifrado.


°°°°°°°°° CryptoUtil °°°°°°°°°°

Se convierte la clase en un componenete de spring boot.

*Donde se crean los atributos de clase*
 private var algorithm: String = "AES/CBC/PKCS5Padding"
 private var keyAlgorithm: String = "AES"

 @Value("\${secretKey}")
 private var secretKey: String = ""


// Decodifica Base64 si es posible, sino usa el string como está
    private fun decodeBase64OrString(input: String): ByteArray {
        return try {
            // Intenta decodificar como Base64
            Base64.getDecoder().decode(input)
        } catch (e: Exception) {
            print(e.message)
            // Si falla, usa el string como bytes UTF-8
            input.toByteArray(Charsets.UTF_8)
        }
    }

// Cache para los bytes decodificados
    private val secretKeyBytes: ByteArray by lazy {
        decodeBase64OrString(secretKey)
    }

    fun cifrar(texto: String): String {
        try {
            // Validar que las llaves estén configuradas
            validarConfiguracion()

            // Crear la clave secreta desde bytes decodificados
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // 🎲GENERAR IV ALEATORIO (nuevo por cada cifrado)
            val ivAleatorio = ByteArray(16)
            SecureRandom().nextBytes(ivAleatorio)
            val ivParameterSpec = IvParameterSpec(ivAleatorio)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)

            // Cifrar el texto
            val textoCifrado = cipher.doFinal(texto.toByteArray(Charsets.UTF_8))

            // Devolver: IV_aleatorio + texto_cifrado (ambos en Base64)
            return Base64.getEncoder().encodeToString(ivAleatorio) + ":" +
                    Base64.getEncoder().encodeToString(textoCifrado)

        } catch (e: Exception) {
            throw Exception("Error al cifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para cifrar.

private fun validarConfiguracion() {
        if (secretKey.isBlank()) {
            throw IllegalStateException("La clave secreta no está configurada")
        }
    } -> Funcion para validar que exista la llave para cifrar y descrifrar.

fun descifrar(textoCifradoCompleto: String): String {
        try {
            // Validar que las llaves estén configuradas
            validarConfiguracion()

            // SEPARAR IV y texto cifrado (formato: "IV_base64:texto_base64")
            val partes = textoCifradoCompleto.split(":")
            if (partes.size != 2) {
                throw IllegalArgumentException("Formato inválido. Debe ser: IV_base64:textoCifrado_base64")
            }

            val ivDecodificado = Base64.getDecoder().decode(partes[0])
            val textoCifradoDecodificado = Base64.getDecoder().decode(partes[1])

            // Crear la clave secreta
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // Crear el vector de inicialización desde el IV recibido
            val ivParameterSpec = IvParameterSpec(ivDecodificado)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec)

            // Descifrar el texto
            val textoDescifrado = cipher.doFinal(textoCifradoDecodificado)

            return String(textoDescifrado, Charsets.UTF_8)

        } catch (e: Exception) {
            throw Exception("Error al descifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para descifrar.

En el mismo controller, crear endpoints que llamen a la funciónes para cifrar y descifrar.



CREAR CLASE PARA INYECTAR VALORES 

@Configuration
@ConfigurationProperties(prefix = "clavePrincipal")
class CryptoConfig {
    var nombreAtributo1: String = ""
    var nombreAtributo2: String = ""
    var nombreAtributoN: String = ""
} -> Para crear una clase que contiene puros atributos, los cuales almacenaran valores de un
	application-personalizado.
	- @ConfigurationProperties(prefix = "clavePrincipal") -> Busca en el application default y despues 		busca en el application activo y al final busca en otros application extra activos las 
		claves que empiencen con el nombre clavePrincipal. 
		Se debe considerar que los valores se pueden sobreescribir, de tal modo que el ultimo 			application en escribir el valor para una clave, se tomara ese valor. **

*En un application*
clavePrincipal:
    clave1: valor1
    clave2: valor2
    claveN: valorN 

