

///////////////////////////////////////////////CRUD////////////////////////////////////////////////////////


DEFINICION DE CLASES ENTITY

Aquí todas las anotaciones como @Entity, @Id, @GeneratedValue(strategy = GenerationType.IDENTITY), entre
otras, se usan igual.

Las clases entity y dto deben ser data class. Una data class es una clase diseñada para almacenar o representar datos y no comportamiento. Kotlin genera automáticamente para ella: equals() (comparación por contenido), hashCode(), toString(), copy(), componentN() (usado para desestructuración como en js 
(val (a, b) = obj)). Esto lo puede hacer java con la anotación Loombok

Las anotaciones para validaciones o restricciones de atributos en Kotlin con Spring Boot funcionan igual
que en Java, pero la sintaxis cambia:
@field:NombreAnotacionRestriccion

@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
) ->
	La unica diferencia es que en el atributo id, se usas var porque se genera y se asigna automáticamente c	cuando guardas el objeto (no tienes que darlo tú).
	Es nullable (Long? = null) porque inicialmente no tiene valor, y solo la base de datos lo asignará.
	Es mutable (var) para que JPA pueda asignar el valor al guardar.

En Kotlin, no se necesita escribir manualmente los getters y setters como en Java. Kotlin los genera automáticamente cuando se define una propiedad.


CAPA DE REPOSITORY

La sintaxis para las interface es:

import com.alejandro.crudKotlin.entities.NombreEntidadX
import org.springframework.data.jpa.repository.JpaRepository

interface NombreEntidadXRepository : JpaRepository<NombreEntidadX, Long> {
    
}


CAPA DE SERVICE

La sintaxis para las interface es:

interface ActorService {

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

}

Para las clases implementadoras:

@Service
class NombreClaseXServiceImpl(
    private val objetoXRepository: NombreClaseXRepository
) : NombreClaseXService {
    // contenido
} -> Define una clase implementadora llamada NombreEntidadXServiceImpl, implementará los métodos definidos 	en la interfaz NombreEntidadXService.
	Kotlin permite definir el constructor en la misma línea que la clase asi que, esta es la manera de
	inyectar una instancia del repositorio (gracias a @Service).

Los métodos mas o menos quedan: 

@Transactional
override fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, 
	parN: tipoDatoN): tipoDatoReturn
{
        // contenido
}


CAPA DE CONTROLLER

@RestController
@RequestMapping("/api/arrayX")
class NombeEntidadXController(
    private val service: NombeEntidadX
) {}

El tipo de dato: ResponseEntity<?> es reemplazado por: ResponseEntity<*>.


///////////////////////////////////////////////OTROS//////////////////////////////////////////////////////


DEPURACION

import org.slf4j.Logger
import org.slf4j.LoggerFactory

private val log = LoggerFactory.getLogger(this::class.java) -> -> Para registrar mensajes de log en 
	la clase en la que está definido.


ANOTACIONES JSON


@JsonAlias("nombre1", "nombre2", "nombreN")
var nombreAtributoX: tipoDato = valorInicial -> El uso de esta anoptacion es sin el modo de acceso 
	private porque el modo de acceso tiene que ser public para que Jackson (u otras libs como Moshi) 	accedan directamente a las propiedades para deserializar.
	Ademas Kotlin genera automáticamente los getters y setters públicos.
	Esta anotación normalmente se usara en clases que representen un dto.

@get:JsonProperty("nombreAtributoXJson")
var nombreAtributoX: tipoDato = valoInicial -> Para que cuando se serialice este atributo, este atributo en
	el objeto json se llame: 'nombreAtributoXJson' y no 'nombreAtributoX'.


CREAR COMPONENTES/BEANS

En la raíz del proyecto se crea el paquete config/ y dentro de él una clase llamada AppConfig.

@Configuration
class AppConfig {} -> Pertmite definir beanes dentro de la clase.

@Bean
fun objetoBean(): NombreClaseBean {
   return NombreClaseBean()
} -> Crea un bean.


INYECCION DE DEPENDENCIAS

class NombreClaseZ(
    private val nombreObjetoX: NombreComponenteX 
) -> Inyección por constructor. Esta es la manera mas recomendada en un proyecto de spring boot + kotlin.

@Autowired
private lateinit var nombreObjetoX: NombreComponenteX -> Inyección por atributo. Como este atributo lo 
	inicializa spring boot en tiempo de ejecución si no se pone el lateinit kotlin piensa que no tiene
	valor, entonces se coloca eso para indicar que tomara un valor después (cuando spring boot lo 
	inicialice).


CONFIGURACION DEL CORS

En el package config/ crear una clase llamada: 'CorsConfig'.

@Configuration
class CorsConfig : WebMvcConfigurer {} -> Crea una clase de configuración para el cors.

override fun addCorsMappings(registry: CorsRegistry) {} -> Funcion para configurar al cors.

registry.addMapping("/api/**") -> Habilita el cors a todas estas rutas. 
	Todas las rutas que no esten aquí no se les habilitara el cors.

.allowedOrigins("*") -> Permite que cualquier origen (dominio ó IP y puerto) pueda hacer solicitudes CORS.
	- .allowedOrigins("http://ip_servidor:numPuerto") -> Permite que cualquier origen (IP y puerto) 		pueda hacer solicitudes CORS.
	- .allowedOrigins("http://url-fron") -> Permite que cualquier origen (domiio) pueda hacer 			solicitudes CORS.

.allowedMethods("*") -> Indica que permite todo tipo de métodos http sean consumidos.
	- .allowedMethods("NOMBRE_METODO_HTTP", "NOMBRE_METODO_HTTP", "NOMBRE_METODO_HTTP") -> Para
		que solo se permitan ciertos metodos http.

.allowCredentials(true) -> Para poder recibir cookies y hearders de autenticacion.
	Comunmente usado cuando se impementa spring security.

Wildcards en addMapping -----------------------------

/api/* -> Toma cualquier valor en un único sub nivel siguiente.
	Entonces si tenemos las rutas /api/uno, /api/dos, /api/tres y /api/cuatro/cinco y aplicamos /api/* 	en addMapping, se aplicaria a todas las rutas menos a /api/cuatro/cinco porque tiene dos subniveles
	siguientes después de /api/.

/api/** -> Se aplica a cualquier cantidad de subrutas dentro de api.
	Por ejemplo a /api/uno, /api/cuatro/cinco y /api/seis/siete/ocho.

/api/*/sub-nivel-dos -> Para que tome cualquier valor en el subnivel que esta entre el 1 y 3.
	Esta forma es útil cuando tenemos un @RequestMapping con @PathVariable como por ejemplo:
	@RequestMapping("/v4/{business}/clupp-CAR") porque .addMapping(...), NO puede interpretar los {} 	como tal @RequestMapping. *******


AWS JAVA SDK FOR AMAZON S3

<dependency>
	<groupId>com.amazonaws</groupId>
	<artifactId>aws-java-sdk-s3</artifactId>
	<version>1.12.772</version>
</dependency> -> Al menos esta versión agarro bien con spring boot v3.5.6 y jdk 17.

Esa dependencia de Maven sirve para que tu aplicación Java pueda interactuar con Amazon S3 usando 
el SDK oficial de AWS.

En otras palabras, te proporciona:
Clases cliente para conectarte a S3.
Métodos para operaciones comunes, como subir, descargar, listar o eliminar objetos.
Manejo de autenticación y configuración con AWS.

val metadata = ObjectMetadata() -> Crea un objeto que se usa guardar metadatos de un archivo (por 
	ejemplo, tipo de contenido, longitud, etc.).

metadata.contentType = "tipoContenido" -> Define el tipo de contenido del archivo.
	- "application/pdf" -> Define que el contenido es un PDF.
	- "application/msword" -> Define que el contenido es un Word (.doc).
	- "application/vnd.openxmlformats-officedocument.wordprocessingml.document" -> Define que 
		el contenido es un Word moderno (.docx).
	- "application/vnd.ms-excel" → Excel (.xls).

Un PDF, imagen, video, etc., en su forma natural son bytes (números binarios).
Esos bytes no siempre son fáciles de enviar por texto (JSON, XML, etc.), así que se transforman a una cadena de caracteres usando Base64.
Luego, en tu código, para volver a usarlo como archivo, debes decodificarlo para regresar de esa cadena al arreglo de bytes original.

archivo en Base64: forma de representar datos binarios (como imágenes, documentos o ejecutables) en texto plano, usando 64 caracteres básicos: A-Z, a-z, 0-9, +, / y = (para relleno).
Esta representación se usa para Transmitir datos binarios por canales que solo admiten texto (como correos electrónicos, APIs o JSON).

val archivoBytes = Base64.getDecoder().decode(archivoBase64) -> Para decodificar un archivo en base 64 	(convertir de vuelta a su formato original, el cual viene a ser el archivo en bytes).

Se tuvo una situación en la que se consumio una api soap externa el cual devolvio un archivo en Base64 dentro de un JSON, el campo vino entre comillas, algo como: {"documento": "JVBERi0xLjUK... (base64) ..."} 
Al extraer el valor de documento, obtendrías: val documento = "\"JVBERi0xLjUK...\"". Las comillas son parte del String, no del Base64 válido. Si no se eliminan, la decodificación fallará. Entonces antes usar la anterior instrucción se elminaron las comillas con: val cleanDocument = dirtyDocument.replace("\"", ""). ***

val byteFlow = ByteArrayInputStream(archivoBytes, 0, archivoBytes.size) -> Crea un InputStream (flujo de 
	entrada de datos) a partir del archivoBytes.
	Se hace esta conversión porque muchas librerías y funciones necesitan los datos en este tipo
	de dato.
	- byte: El array de bytes que representa al archivo.
	- 0: Offset inicial (lee desde el primer byte del array).
	- byte.size: Longitud del flujo (hasta el último byte del array).


ENVIAR UN PDF A UNA API

val headers = HttpHeaders()
headers.contentType = MediaType.MULTIPART_FORM_DATA -> Crea un objeto para definir cabeceras HTTP e Indica 	que el cuerpo de la solicitud será un formulario multipart (usado para enviar archivos + campos
	de texto).
	Los campos de texto en un multipart/form-data son datos complementarios (los cuales se envían
	en pares de clave - valor) que viajan junto al archivo en una misma petición. 

val map: LinkedMultiValueMap<String, Any> = LinkedMultiValueMap() -> Crea un objeto que representa el cuerpo 	de una solicitud HTTP del tipo multipart/form-data. ****
	- LinkedMultiValueMap: Es una estructura de Spring que permite almacenar múltiples valores para
		 una misma clave (útil para formularios con archivos).

map.apply {
    add("nombreArchivo", MultipartInputStreamFileResource(byteFlow, "nombreArchivo.extension"))
    add("nombreAtributo1", valor1)
    add("nombreAtributo2", valor2)
    add("nombreAtributoN", valorN)
} -> Llena de información el objeto que se enviara en el cuerpo de la solicitud incluyendo el archivo 
	a enviar.
	La variable byteFlow es una variable de tipo inputStream que representa el archivo a enviar. ***
	- MultipartInputStreamFileResource: Es una clase que envuelve un InputStream y le agrega 
		información necesaria para que pueda enviarse correctamente en el cuerpo de la solicitud 
		HTTP como parte de un multipart/form-data.

internal class MultipartInputStreamFileResource(inputStream: InputStream?, private val filename: String) :
    InputStreamResource(inputStream!!) {
    override fun getFilename(): String {
        return filename
    }

    @Throws(IOException::class)
    override fun contentLength(): Long {
        return -1
    }
} -> Clase personalizada.
	- getFilename: por defecto, InputStreamResource no tiene nombre de archivo, y para 
		multipart/form-data es obligatorio asi que se sobrescribe el método getFilename() para 
		indicarle al servidor receptor el nombre de este archivo.
	- contentLength: se sobreescribe para indicarle a spring que No sabemos la longitud del contenido
		 y no la vamos a calcularla, así que lo envie tal cual sin intentar leerlo todo antes.
	- InputStreamResource es una clase de Spring que envuelve un InputStream para poder enviarlo en 
		una request HTTP.

val requestEntity: HttpEntity<LinkedMultiValueMap<String, Any>> = HttpEntity(map, headers) -> Crea
	el objeto que contiene toda la información que se enviará en una solicitud HTTP, incluyendo tanto 	los datos (el cuerpo de la solicitud) como los headers (metadatos como el tipo de contenido).



///////////////////////////////////////////////CLIENTES//////////////////////////////////////////////////


REST TEMPLATE
	
Incluida en la dependencia: spring-boot-starter-web.

Crear el paquete llamado config/ y dentro de este una clase de configuración, ahí crear el bean para
restTemplate.

@Configuration
class AppConfig {

    @Bean
    fun restTemplate(): RestTemplate {
        return RestTemplate()
    }

} -> declararlo como un @Bean a restTemplate.


En una clase service ---------------------------------------------

Inyectar el componenete por medio de autowired o constructor primario.

@Service
class NombreClaseXServicio(private val restTemplate: RestTemplate) {}

val headers = HttpHeaders() -> Permite la definición del header.

headers.accept = listOf(MediaType.APPLICATION_JSON) -> Para indicar que esperamos el cuerpo de la respuesta 	que da el servidor en formato json.

headers.setBearerAuth("token") -> Para agregar el token de autorización de tipo Bearer que necesita la
	petición.

val entity = HttpEntity<String>("", headers) -> Crea un objeto HttpEntity que encapsula dos cosas:
	El cuerpo (body) de la solicitud y los encabezados.

val response = restTemplate.exchange(
    url,
    HttpMethod.NOMBRE_METODO_HTTP,
    entity,
    NombreTipoDato
) -> Realiza cierta petición a un servidor.


°°°°° Métodos de JSONArray °°°°°°°

Para usar JSONObject, toJSONObject, etc se debe importar la 
dependencia 'org.json'.

Doc oficial:
https://mvnrepository.com/artifact/org.json/json

<dependency>
  <groupId>org.json</groupId>
  <artifactId>json</artifactId>
  <version>20240303</version> 
</dependency> -> Al menos esta versión agarro bien con spring boot
	v3.5.3

val lista: MutableList<JSONObject> = mutableListOf() -> Crea una lista mutable vacía que almacenará 
	objetos de tipo json.

arregloJson.getJSONObject(i) -> Del arreglo de objetos json devuelve el objeto JSON que está en la 
	posición i.

JSONArray(lista) -> Convierte una lista de JSONObject en un JSONArray.


°°°°° Método de JSONObject °°°°°°°

JSONObject(response.body) -> Convierte un json string a un objeto json.

objetoJson.getJSONArray("nombreClave") -> Accede a determinado atributo o clave del objeto json.

val objetoJson = JSONObject() -> Crea un objeto json.

objetoJson.put("Id", Id) -> Crea una clave y le asigna un valor dentro de un objeto json.

objetoJson.getTipoDatoY("nombreClaveX") -> Dentro del objeto json busca y extrae el valor asociado a 
	cierto clave (atributo)	y la convierte al tipo de dato ye.
	Si no encuentra el atributo o no es un valor casteable lanzara null pointer exception.

objetoJson.optTipoDatoY("nombreClaveX", valorDefecto) -> Dentro del objeto json busca y extrae el valor 	asociado a cierto clave (atributo) y la convierte al tipo de dato ye.
	Si no encuentra el atributo o no es un valor casteable devuelve el valor por defecto.


°°°°° Extraer determinados valores de una arreglo obtener un nuevo arreglo °°°°°°°

val response = restTemplate.exchange(
    url,
    HttpMethod.NOMBRE_METODO_HTTP,
    entity,
    String::class.java // obligatorio
)

val JSONArray = JSONObject(resp.body)

val objectJsonList: MutableList<JSONObject> = mutableListOf()

for (i in 0 until JSONArray.length()) {
    val currentJsonObject = JSONArray.getJSONObject(i)

    val newJsonObject = JSONObject().apply {
	jsonObject.put("nombreClave1", currentJsonObject.getTipoDato("nombreClave1"))
        jsonObject.put("nombreClave2", currentJsonObject.getTipoDato("nombreClave2"))
        jsonObject.put("nombreClaveN", currentJsonObject.getTipoDato("nombreClaveN"))    

    }
             

    objectJsonList.add(newJsonObject)
}


GSON

Es una biblioteca de Java que se puede usar para convertir objetos Java en su 
representación JSON. También se puede utilizar para convertir una cadena JSON en un
objeto Java equivalente.

Hace lo mismo que object mapper la diferencia que object mapper es:
Más rápida y eficiente en general.
Mucho más flexible y configurable.
Soporta muchas anotaciones (@JsonProperty, @JsonIgnore, etc.).
Mejor manejo de tipos complejos, Map, genéricos, List, etc.
Mejor soporte oficial para Kotlin si usas el módulo jackson-module-kotlin

Concusion es mejor object mapper.

<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.10.1</version>
</dependency> -> Agarro bien con la versión de spring boot 3.5.3 y jdk 17.



//////////////////////////////////////INYECCION DE VALORES//////////////////////////////////


INYECTAR VALORES QUE VIENEN DE ARCHIVOS PROPERTIES

Estos valores son de configuracion y se crean dentro de archivos de tipo properties para ser
utilizados en uno o mas clases. 

Utilizando el archivo de properties que viene por defecto -----------------------


°°°°°°° En nombreProyecto\demo\src\main\resources\application.properties °°°°°°°

config.nombreAtributoX=valor -> Crea un valor de configuracion.
	Si el valor es string NO se envuelve entre comillas dobles. NO se debe utilizar 
	acentos en las cadenas ni otros caracteres especiales.


°°°°°°° En la clase donde se utilizara los valores de configuracion °°°°°°°

*Donde se definen atributos de clase*
@Value("\${config.nombreAtributoX}")  
private lateinit var nombreAtributoX: String -> Para poder inyectar los valores que estan en 
	los archivos de properties a la clase actual mediante creacion de atributos de clase.

Si se tiene levantada la app, se debe reiniciar después de hacer esto.
 

