@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
) ->
	La unica diferencia es que en el atributo id, se usas var porque se genera y se 
	asigna automÃ¡ticamente cuando guardas el objeto (no tienes que darlo tÃº).
	Es nullable (Long? = null) porque inicialmente no tiene valor, y solo la base de 
	datos lo asignarÃ¡.
	Es mutable (var) para que JPA pueda asignar el valor al guardar.

Lo malo de kotlin es que para instanciar objetos de clases entity es necesario pasarle valores a todos
los atributos, incluyendo al id aunque este lo genere automÃ¡ticamente jpa, lo comÃºn es asignarle el 0.
U otra alternativa es usar named arguments, cuando se instancie un objeto se debe especificar a que atributo
va cada valor y en este caso se omitirÃ­a el nombre del atributo id.

val objetoX = NombreClaseX(
    nombreAtributo1 = valor1,
    nombreAtributo2 = valor2,
    nombreAtributoN = valorN,
)



///// OTROS ///////////////////////////////////////////////////

CONSULTAS NATIVAS

Es cuando en un mÃ©todo dentro de una clase repositorio hace una consulta personalizada usando la anotaciÃ³n
query y usando sql nativo (la sintaxis de sql y no la jpql).
Hacerlo de esto modo tiene la caracterÃ­stica que el resultado serÃ¡ de tipo 'TupleBackedMap' (resultado genÃ©rico de una consulta nativa).

Para convertir el resultado de una consulta nativa a un objeto java hay varias formas: 1. si el objeto de 
retorno coincide con un objeto de una clase entity, en este caso spring boot harÃ¡ la conversiÃ³n 
automÃ¡ticamente 2. si el objeto de retorno debe ser un dto, se deben aplicar diversas tÃ©cnicas.

Convertir el objeto de retorno de una consulta nativa a un dto -----------------------------------

Se debe hacer un mapeo explÃ­cito con: @SqlResultSetMapping, @ConstructorResult, proyecciÃ³n de interfaz o constructor expresivo en JPQL.

Â°Â°Â°Â°Â°Â°Â°Â° Usando proyecciÃ³n Â°Â°Â°Â°Â°Â°Â°

Esta forma se usa cuando el dto nunca se necesita para instanciar objetos en todo el proyecto, solo se
ocupara para cachar lo que retornan las consultas nativas.

interface NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
} -> Cambiar la clase dto por una interface.
	Si se define un DTO como interfaz, Spring hace el mapeo por nombre de columnas, entonces las
	queries deben devolver las columnas con los mismos nombres de atributos de la interface dto.


Â°Â°Â°Â°Â°Â°Â°Â° Usando proyecciÃ³n + clase dto Â°Â°Â°Â°Â°Â°Â°

Esta forma se usa cuando el dto se necesita para instanciar objetos en alguna parte del proyecto y mas
aparte se necesita la proyecciÃ³n para cachar lo que retornan las consultas nativas.
 
*se crea la proyecciÃ³n*

data class NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
}

*En un mÃ©todo de servicio*
*Al usar un mÃ©todo repositorio que hace la consulta nativa*
objetoXRepository.nombreMetodoX().map {
        NombreClaseDto(it.nombreAtributo1, it.nombreAtributo2, it.nombreAtributoN)
} -> se debe convertir el resultado a la clase dto.


ENTITY MANAGER
 
Es una alternativa a usar las operaciones que brinda una clase repository que implmenta el Spring Data de jpa.
Se usa en consultas dinÃ¡micas donde el nombre de la tabla o campos cambian, porque en las consultas de jpa 
solo se puede cambiar dinÃ¡micamente el valor que se le pasan a los campos y no el nombre de tablas o 
campos. ******

Se crea una clase llamada: NombreClaseXRepository y se le inyecta el objeto entityManager.

@Repository
class NombreClaseXRepository(
    @PersistenceContext private val entityManager: EntityManager
) {...} -> Crea una clase y la vuelve un componente de spring boot.
	Inyecta el objeto entityManager el cual sirve para ejecutar consultas JPQL o nativas y Persistir o 
	eliminar entidades.

*Dentro de algun metodo*

val sql = """
            sentencia sql
        """.trimIndent() -> Se crea un string el cual contiene a la operaciÃ³n sql a realizar.

Crear queries ----------------------------------

val query = entityManager.createNativeQuery(sql) -> Crea un objeto Query que representa la consulta
	a realizar (No ejecuta nada todavÃ­a).
	La variable sql contiene una operaciÃ³n de sql nativa. ***

val query = entityManager.createQuery(sql, NombreClaseEntidadX::class.java) -> Crea un objeto Query que 	representa la consulta a realizar (No ejecuta nada todavÃ­a).
	La variable sql contiene una operaciÃ³n de sql nativa. ***
	El resultado se mapeara automÃ¡ticamente a entidades JPA.

query.setParameter("paramName", valor) -> Para inyectar valores a nivel (WHERE), SET en UPDATE, INSERT.
	No funciona para inyectar el nombre de tablas. ****
	En la consulta sql irÃ­a algo como: ':paramName' y para inyectar ese valor seria con esta 
	instrucciÃ³n.  
	
Para ejecutar consultas ------------------------

query.getResultList() â†’ Ejecuta la consulta y devuelve una lista de resultados.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.resultList as List<Array<Any>>
	  return result.map {
    		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		)
	  } -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
		el arreglo de filas en una lista de objetos dto.
		- cols[0].toString() -> Esta seria la manera de convertir un campo que contiene un 
			valor diferente de string a string (pe convertir un int, bigInt, etc a string).

query.getSingleResult() â†’ Ejecuta la consulta y devuelve un solo resultado.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.singleResult as Array<Any>
		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		) -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
			la fila en un objeto dto.

query.executeUpdate() â†’ Para insert, update o delete (no devuelve filas).


Se tuvo la situaciÃ³n de que se particiono una tabla mediante la tÃ©cnica de particiÃ³n por catÃ¡logos, de 
tal modo que se tenia una tabla llamada extracciÃ³n y contenÃ­a datos de todos los vehÃ­culos pero habÃ­a
muchos tipos de vehÃ­culos asi que se creo una tabla para cada tipo de vehiculo obteniendo las tablas:
extraccion_auto, extraccion_tractocamion y extracciÃ³n_pickup. Cada una de estas 3 tablas evidentmente
tenÃ­an la misma estructura que la tabla original (tabla extraccion).
Entonces al hacer este cambio las consultas que habÃ­an originalmente quedaron totalmente igual pero ahora
habÃ­a que cambiar dinamicamnete el nombre de la tabla para que apuntara de acuerdo al tipo de camiÃ³n
buscado. Entonces para eso se uso entity manager.



//////AVANZADO //////

CIFRADO Y DESCIFRADO DE DATOS

Utilizado para cifrar llaves y credenciales, tambien para cifrar tokens.

TeorÃ­a ------------------------------------------------------

Initialization Vector (IV): es un valor ALEATORIO que asegura que un mismo texto al ser cifrado con la misma
llave se obtenga siempre un diferente resultado.
Un IV siempre debe ser:
 	ÃšNICO: Nunca reusar el mismo IV con la misma clave
	ALEATORIO: Debe ser impredecible (usar SecureRandom).

TamaÃ±o del iv segÃºn el algoritmo:
Algoritmo	TamaÃ±o de bloque	TamaÃ±o de IV requerido
AES	        128 bits (16 bytes)	16 bytes
DES	        64 bits (8 bytes)	8 bytes
3DES	       64 bits (8 bytes)	8 bytes
Blowfish	64 bits (8 bytes)	8 bytes

Aes
Longitudes:
TamaÃ±o	       Bits	Intentos para romper	Tiempo estimado
16 bytes	128	2Â¹Â²â¸	Billones de aÃ±os
24 bytes	192	2Â¹â¹Â²	Edad del universo
32 bytes	256	2Â²âµâ¶	MÃºltiples edades del universo


Flujos --------------------------------------------------

Cifrado:
	Generar IV aleatorio nuevo
	Cifrar texto con clave + IV aleatorio
	Concatenar: IV_aleatorio + texto_cifrado
	Devolver todo en Base64

Descifrar:
	Separar IV y texto cifrado
	Descifrar con clave + IV recibido
	Devolver texto plano
	

Configuraciones -----------------------------------------

Se crea un application llamado: application-secrets. AquÃ­ se depositan la llave que se usa para cifrar y 
descifrar (secretKey) y otras claves y valores sensibles.

*En application-secrets*
 clave1: valor1
 clave2: valor2
 claveN: valorN 

*En application-default*
spring.profiles.include=secrets -> Le dice a Spring que active el perfil "secrets" ADEMÃS de los perfiles
	ya activos.
	De esta manera es como si esta configuraciones se incluyen automÃ¡ticamente en todos los entornos.


En utils/crypto/ ---------------------------------------

Crear la clase que genera la llave que va en application-secrets.

Â°Â°Â°Â°Â°Â°Â°Â°Â° KeyGeneratorUtil Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°

// Para poder generar una nueva llave de cifrado cada que asi se necesite
object KeyGeneratorUtil {

    @Throws(Exception::class)
    fun generarClaveSecreta(tamanio: Int): Map<String, String> {
        require(tamanio == 16 || tamanio == 24 || tamanio == 32) {
            "TamaÃ±o debe ser 16, 24 o 32"
        }

        val keyGen = KeyGenerator.getInstance("AES")
        keyGen.init(tamanio * 8)
        val secretKey = keyGen.generateKey()
        val claveBase64 = Base64.getEncoder().encodeToString(secretKey.encoded)

        return mapOf(
            "base64" to claveBase64,
            "string" to String(Base64.getDecoder().decode(claveBase64), Charsets.UTF_8),
            "tamanio" to tamanio.toString(),
            "bits" to (tamanio * 8).toString()
        )
    }

    fun generarLlavesCompletas(tamanioClave: Int = 32): Map<String, Any> {
        val clave = generarClaveSecreta(tamanioClave)

        return mapOf(
            "clave" to clave,
            "yamlConfig" to """
                crypto:
                  secret-key: "${clave["string"]}"
                  algorithm: "AES/CBC/PKCS5Padding"
                  key-algorithm: "AES"
            """.trimIndent()
        )
    }

}

Crear un Controller que llama a la funciÃ³n generarLlavesCompletas() y la llave colocarla en el
application-secrets.
De todos los valores que retorna la funciÃ³n, la llave vendrÃ­a a ser la correspondiente al atributo base64.

Generar el servicio de cifrado y descifrado.


Â°Â°Â°Â°Â°Â°Â°Â°Â° CryptoUtil Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°

Se convierte la clase en un componenete de spring boot.

*Donde se crean los atributos de clase*
 private var algorithm: String = "AES/CBC/PKCS5Padding"
 private var keyAlgorithm: String = "AES"

 @Value("\${secretKey}")
 private var secretKey: String = ""


// Decodifica Base64 si es posible, sino usa el string como estÃ¡
    private fun decodeBase64OrString(input: String): ByteArray {
        return try {
            // Intenta decodificar como Base64
            Base64.getDecoder().decode(input)
        } catch (e: Exception) {
            print(e.message)
            // Si falla, usa el string como bytes UTF-8
            input.toByteArray(Charsets.UTF_8)
        }
    }

// Cache para los bytes decodificados
    private val secretKeyBytes: ByteArray by lazy {
        decodeBase64OrString(secretKey)
    }

    fun cifrar(texto: String): String {
        try {
            // Validar que las llaves estÃ©n configuradas
            validarConfiguracion()

            // Crear la clave secreta desde bytes decodificados
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // ğŸ²GENERAR IV ALEATORIO (nuevo por cada cifrado)
            val ivAleatorio = ByteArray(16)
            SecureRandom().nextBytes(ivAleatorio)
            val ivParameterSpec = IvParameterSpec(ivAleatorio)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)

            // Cifrar el texto
            val textoCifrado = cipher.doFinal(texto.toByteArray(Charsets.UTF_8))

            // Devolver: IV_aleatorio + texto_cifrado (ambos en Base64)
            return Base64.getEncoder().encodeToString(ivAleatorio) + ":" +
                    Base64.getEncoder().encodeToString(textoCifrado)

        } catch (e: Exception) {
            throw Exception("Error al cifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para cifrar.

private fun validarConfiguracion() {
        if (secretKey.isBlank()) {
            throw IllegalStateException("La clave secreta no estÃ¡ configurada")
        }
    } -> Funcion para validar que exista la llave para cifrar y descrifrar.

fun descifrar(textoCifradoCompleto: String): String {
        try {
            // Validar que las llaves estÃ©n configuradas
            validarConfiguracion()

            // SEPARAR IV y texto cifrado (formato: "IV_base64:texto_base64")
            val partes = textoCifradoCompleto.split(":")
            if (partes.size != 2) {
                throw IllegalArgumentException("Formato invÃ¡lido. Debe ser: IV_base64:textoCifrado_base64")
            }

            val ivDecodificado = Base64.getDecoder().decode(partes[0])
            val textoCifradoDecodificado = Base64.getDecoder().decode(partes[1])

            // Crear la clave secreta
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // Crear el vector de inicializaciÃ³n desde el IV recibido
            val ivParameterSpec = IvParameterSpec(ivDecodificado)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec)

            // Descifrar el texto
            val textoDescifrado = cipher.doFinal(textoCifradoDecodificado)

            return String(textoDescifrado, Charsets.UTF_8)

        } catch (e: Exception) {
            throw Exception("Error al descifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para descifrar.

En el mismo controller, crear endpoints que llamen a la funciÃ³nes para cifrar y descifrar.



CREAR CLASE PARA INYECTAR VALORES 

@Configuration
@ConfigurationProperties(prefix = "clavePrincipal")
class CryptoConfig {
    var nombreAtributo1: String = ""
    var nombreAtributo2: String = ""
    var nombreAtributoN: String = ""
} -> Para crear una clase que contiene puros atributos, los cuales almacenaran valores de un
	application-personalizado.
	- @ConfigurationProperties(prefix = "clavePrincipal") -> Busca en el application default y despues 		busca en el application activo y al final busca en otros application extra activos las 
		claves que empiencen con el nombre clavePrincipal. 
		Se debe considerar que los valores se pueden sobreescribir, de tal modo que el ultimo 			application en escribir el valor para una clave, se tomara ese valor. **

*En un application*
clavePrincipal:
    clave1: valor1
    clave2: valor2
    claveN: valorN 



/////////////////////////MONGODB CON SPRING BOOT////////////////////////////////////////


TEORIA PARA SPIRNG DATA MONGODB

Cuando insertas el primer documento en una collection que no existe, MongoDB crea la collection automÃ¡ticamente en ese momento asi que No hay necesidad de crear collections explÃ­citamente.
Es por eso que cuando se trabaja con mongoDb no existe la configuraciÃ³n ddl-auto=valor.


CONFIGURACIONES CON MONGODB

logging.level.org.springframework.data.mongodb=DEBUG
logging.level.org.mongodb=DEBUG -> Para ver con detalle las operaciones que se hacen en mongoDb.
	Equivalente a la instrucciÃ³n: 'spring.jpa.properties.hibernate.show-sql=true'. *****
	En los logs se vera informaciÃ³n como:
		Operaciones de find (consultas)
		Inserts de documentos
		Updates y modificaciones
		Delete operations
		Aggregations y pipelines
		Conexiones y comandos enviados al servidor MongoDB
	Estos valores se usan para el perfil de dev por que son bansante detallados para prod se usarÃ­a:
	INFO y WARN para esas dos instrucciones respectivamtne.

logging.level.org.mongodb.driver.cluster=INFO -> Para no mostrar los logs que son de monitoreo del 
	cluster de MongoDB.
	Si no se ocultan, a cada rato se mostraran mensajes de MongoDB Driver que hace para verificar el 	estado del servidor.
	
spring.data.mongodb.auto-index-creation=true -> crea automÃ¡ticamente Ã­ndices definidos con @Indexed en 
	las collections.


CLASES ENTITY CON MONGODB

@Field -> Ãšnicamente sirve para indicar el nombre que tiene el atributo en el campo de la collecion y 
	no tiene mas configuraciones. ****
	Nunca apliarselo al campo id porque mongoDb siempre necesita que el campo se llame id para 	identificador primario. ***************

@Indexed() -> Sirve para crear Ã­ndices.
	- name = "idx_nombre_indice" -> Para darle un nombre al indice.
	- direction = IndexDirection.DESCENDING -> Indica que el ordenamiento sera descendente.


Alternativa a columnDefinition de spring data jpa ------------------------

Cuando se tienen un campo en una tabla con cierto tipo de dato pero en el cÃ³digo se quiere trabajar con 
ese mismo campo pero con otro tipo de dato, se suele usar la configuraciÃ³n columnDefinition de la anotaciÃ³n
@Column, pero en mongoDb eso no existe.
Pe se ha tenido la situaciÃ³n de tener un campo int en una tabla pero en el cÃ³digo se desea trabajar como
si ese campo fuera de tipo string (varchar).

Para lograr el mismo efecto en con spring data mongoDb se agrega el siguiente cÃ³digo:

data class Extraccion (
    private var _claveInt: Int = 0
) {

    var clave: String
        get() = _claveInt.toString()
        set(value) { _claveInt = value.toIntOrNull() ?: 0 }

    var marca: String = ""

    var submarca: String = ""
} -> De esta manera solo un campo (el campo clave) se trata como si fuera string en el cÃ³digo pero en 
	la tabla es int y los demÃ¡s atributos se tratan de manera normal.
	Observese que los campos no se definen en () si no dentro de {}. *********


REPOSITORIES CON MONGODB

interface NombreEntidadXRepository : MongoRepository<NombreEntidadX, TipoDatoId> {
    // mÃ©todos personalizados
} -> Para hacer operaciones CRUD + queries personalizadas sobre la entidad NombreEntidadX.
	Para que MongoRepository funcione, la clase NombreEntidadX debe ser una clase con la cual tiene 
	un campo marcado con @Id. ****
	Spring Data se encarga de detectar todas las interfaces que extienden MongoRepository (o 
	JpaRepository, CrudRepository, etc.) gracias al mecanismo de repository scanning. Al arrancar 
	la aplicaciÃ³n, Spring genera un bean automÃ¡tico para esa interface. *****


Consultas personalizadas con @Query -----------------------------

@Query(value = "{}", 
	fields = "{ '_id': 1, 'nombreCampo1': valor, 'nombreCampo2': valor, 'nombreCampoN': valor}")
fun nombreFuncion(): tipoDatoRetorno
	Lo malo de usar esta forma es que si o si se consulta la tabla (collection), que envuelve la
	interace 'MongoRepository'.
	- fileds -> Sirve para incluir o exluir campos segun sea su valor.
		Es como ponerlos o no en el select. ****
		Si no se pone al campo: _id, se incluye automÃ¡ticamente, pero Si lo pones con 0, lo 
		excluyes explÃ­citamente. ****
		Posibles valores:
		- 1 incluye el campo en la salida de la consulta.
		- 0 excluye el campo de la salida.
	- value -> define quÃ© documentos se quieren traer (como un filtro â†’ equivalente al WHERE en SQL).
		Ejemplos:
		- value = "{ 'country': 'MX' }" â†’ filtra solo documentos donde country = "MX".


Consultas personalizadas con MongoTemplate -----------------------------

El objeto MongoTemplate en Spring Data MongoDB permite armar queries dinÃ¡micas y hasta cambiar el nombre de la tabla/colecciÃ³n en runtime (similar a entityManager).

Â°Â°Â°Â°Â°Â°Â°Â°Â°Â° Manera 1 Â°Â°Â°Â°Â°Â°Â°Â°Â°

Manera cuando se hacen operaciones simples.

import org.springframework.data.mongodb.core.query.Query // De este paquete.

*Dentro de un metodo*

val query = Query() -> Crea un objeto query representa la consulta MongoDB que vas a ejecutar con 
	MongoTemplate.

query.fields().include("nombreCampo1", "nombreCampo2", "nombreCampoN") -> Determina que campos nos queremos
	traer.
	Es como el select de sql. ***+

val results = mongoTemplate.find(query, Map::class.java, collectionName) -> Ejecuta la consulta preparada.
	Se indica el nombre de la colleccion a la cual se aplicara la consulta y el nombre de la clase que
	representa tipo de dato que retornara la consulta.
	El nombre de la clase que representa el tio de dato que retonrar la consulta siempre serÃ¡ map,
	despuÃ©s con ese mapa se mapeara a una clase de interÃ©s.

val list: List<NombreClaseDto> = results.map { document ->
    NombreClaseDto(
        nombreAtributo1 = document["nombreCampo1"].toString(),
        nombreAtributo2 = document["nombreCampo2"].toString(),
	nombreAtributoN = document["nombreCampoN"].toString(),
    )
}.toList() -> Manerar de mapear lo que contiene un mapa hacia una clase dto. ****


Â°Â°Â°Â°Â°Â°Â°Â°Â°Â° Manera 2 Â°Â°Â°Â°Â°Â°Â°Â°Â°

Se usa cuando necesitas pipeline avanzado, como:
distinct
group by
count
operaciones de agregaciÃ³n (sum, avg, etc.)
transformar/renombrar campos

import org.springframework.data.mongodb.core.aggregation.Aggregation
import org.springframework.data.mongodb.core.query.Criteria
import org.springframework.data.domain.Sort // De estos pquetes

val aggregation = Aggregation.newAggregation() -> Prepara un consulta.
	Instrucciones que puede recibir.
	- Aggregation.group("nombreCampo") -> Agrupa por determinado campo.
		Cuando se agrupa por mÃºltiples campos, MongoDB los almacena en el objeto llamado '_id'.***
	- Aggregation.sort(Sort.by(Sort.Direction.DESC/ASC, "nombreCampo")) -> Para ordenar asc o desc por
		determinado campo.
	- Aggregation.limit(n) -> Para indicar un limite de resultados.
	- Aggregation.match() -> Para crear filtros.
		condiciones:
		- Criteria.where("marca").`is`(marca)
        	  .and("activo").`is`(true)
        	  .and("stock").gt(0) -> Ejemplo de puros ands.
		- Criteria().orOperator(
        	 	Criteria.where("categoria").`is`("electronicos"),
       			Criteria.where("categoria").`is`("electrodomesticos")
    		  ) -> Ejemplo de puro or.

		Operadores:
			- .lt(1000) -> Menor que
        		- .gte(50) -> Mayor o igual que  
        		- .lte(500) -> Menor o igual que
        		- .`in`(listOf("A", "B", "C")) -> En una lista
        		- .ne("null") -> No igual
        		- .regex("^Nike") -> ExpresiÃ³n regular
	- Aggregation.count().as("total") -> Para hacer un conteo.
	- Aggregation.project() -> Transforma la estructura de salida.
		Metodos que encadenan a esta instrucciÃ³n: 
		- .and("nombreCampo").as("nuevoNombreCampo") -> Renombra determinado campo
		- .andExclude("campo") -> Para Excluir campo.
    		- .andInclude("campo") -> Para Incluir campo
		- .andExpression("precio * cantidad").as("total") -> Hacer operaciones con los campos.

Se supone que el orden de las clausulas: where, select, distinc, group by es indiferente, sin embargo, se 
tuvieron diversos problemas al usuarlos en un orden culqaquiera. Tomando diversas consultas exitosas se
determino que el orden correcto para usar esas clausulas es: match (para hacer condiciones como el where),
group, Project y al final sort. ********

val results = mongoTemplate.aggregate(
    aggregation,
    nombreCollection,
    Map::class.java
).mappedResults -> Ejecuta una consulta de agregaciÃ³n.
	Al igual que la manera anterior, siempre se usa map y ya despuÃ©s se mapea hacia la clase de interÃ©s.

val list: List<NombreClaseDto> = results.map { document ->
    NombreClaseDto(
        nombreAtributo1 = document["nombreCampo1"].toString(),
        nombreAtributo2 = document["nombreCampo2"].toString(),
	nombreAtributoN = document["nombreCampoN"].toString(),
    )
}.toList() -> Manerar de mapear lo que contiene un mapa hacia una clase dto. ****



