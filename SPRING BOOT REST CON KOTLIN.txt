

///////////////////////////////////////////////CRUD////////////////////////////////////////////////////////


DEFINICION DE CLASES ENTITY

Aquí todas las anotaciones como @Entity, @Id, @GeneratedValue(strategy = GenerationType.IDENTITY), entre
otras, se usan igual.

Las clases entity y dto deben ser data class. Una data class es una clase diseñada para almacenar o representar datos y no comportamiento. Kotlin genera automáticamente para ella: equals() (comparación por contenido), hashCode(), toString(), copy(), componentN() (usado para desestructuración como en js 
(val (a, b) = obj)). Esto lo puede hacer java con la anotación Loombok

Las anotaciones para validaciones o restricciones de atributos en Kotlin con Spring Boot funcionan igual
que en Java, pero la sintaxis cambia:
@field:NombreAnotacionRestriccion

@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
)

En Kotlin, no se necesita escribir manualmente los getters y setters como en Java. Kotlin los genera automáticamente cuando se define una propiedad.


CAPA DE REPOSITORY

La sintaxis para las interface es:

import com.alejandro.crudKotlin.entities.NombreEntidadX
import org.springframework.data.jpa.repository.JpaRepository

interface NombreEntidadXRepository : JpaRepository<NombreEntidadX, Long> {
    
}


CAPA DE SERVICE

La sintaxis para las interface es:

interface ActorService {

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

}

Para las clases implementadoras:

@Service
class NombreClaseXServiceImpl(
    private val objetoXRepository: NombreClaseXRepository
) : NombreClaseXService {
    // contenido
} -> Define una clase implementadora llamada NombreEntidadXServiceImpl, implementará los métodos definidos 	en la interfaz NombreEntidadXService.
	Kotlin permite definir el constructor en la misma línea que la clase asi que, esta es la manera de
	inyectar una instancia del repositorio (gracias a @Service).

Los métodos mas o menos quedan: 

@Transactional
override fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, 
	parN: tipoDatoN): tipoDatoReturn
{
        // contenido
}


CAPA DE CONTROLLER

@RestController
@RequestMapping("/api/arrayX")
class NombeEntidadXController(
    private val service: NombeEntidadX
) {}

El tipo de dato: ResponseEntity<?> es reemplazado por: ResponseEntity<*>.


///////////////////////////////////////////////OTROS//////////////////////////////////////////////////////


DEPURACION

import org.slf4j.Logger
import org.slf4j.LoggerFactory

private val log = LoggerFactory.getLogger(this::class.java) -> -> Para registrar mensajes de log en 
	la clase en la que está definido.


DTO

@JsonAlias("nombre1", "nombre2", "nombreN")
var nombreAtributoX: tipoDato = valorInicial -> El uso de esta anoptacion es sin el modo de acceso 
	private porque el modo de acceso tiene que ser public para que Jackson (u otras libs como Moshi) 	accedan directamente a las propiedades para deserializar.
	Ademas Kotlin genera automáticamente los getters y setters públicos.
	

///////////////////////////////////////////////CLIENTES//////////////////////////////////////////////////


REST TEMPLATE
	
Crear el paquete llamado config/ y dentro de este una clase de configuración, ahí crear el bean para
restTemplate.

@Configuration
class AppConfig {

    @Bean
    fun restTemplate(): RestTemplate {
        return RestTemplate()
    }

} -> declararlo como un @Bean a restTemplate.


En una clase service ---------------------------------------------

Inyectar el componenete por medio de autowired o constructor primario.

@Service
class NombreClaseXServicio(private val restTemplate: RestTemplate) {}

val headers = HttpHeaders() -> Permite la definición del header.

headers.accept = listOf(MediaType.APPLICATION_JSON) -> Para indicar que esperamos el cuerpo de la respuesta 	que da el servidor en formato json.

headers.setBearerAuth("token") -> Para agregar el token de autorización de tipo Bearer que necesita la
	petición.

val entity = HttpEntity<String>("", headers) -> Crea un objeto HttpEntity que encapsula dos cosas:
	El cuerpo (body) de la solicitud y los encabezados.

val response = restTemplate.exchange(
    url,
    HttpMethod.NOMBRE_METODO_HTTP,
    entity,
    NombreTipoDato
) -> Realiza cierta petición a un servidor.

JSONObject(response.body) -> Convierte un json string a un objeto json.

objetoJson.getJSONArray("nombreClave") -> Accede a determinado atributo o clave del objeto json.

val lista: MutableList<JSONObject> = mutableListOf() -> Crea una lista mutable vacía que almacenará 
	objetos de tipo json.

arregloJson.getJSONObject(i) -> Del arreglo de objetos json devuelve el objeto JSON que está en la 
	posición i.

val objetoJson = JSONObject() -> Crea un objeto json.

objetoJson.put("Id", Id) -> Crea una clave y le asigna un valor dentro de un objeto json.

objetoJson.getTipoDatoY("nombreClaveX") -> Extrae del objeto json el valor asociado a cierta clave
	y la convierte al tipo de dato ye.

JSONArray(lista) -> Convierte una lista de JSONObject en un JSONArray.


°°°°° Extraer determinados valores de una arreglo obtener un nuevo arreglo °°°°°°°

val response = restTemplate.exchange(
    url,
    HttpMethod.NOMBRE_METODO_HTTP,
    entity,
    String::class.java // obligatorio
)

val JSONArray = JSONObject(resp.body)

val objectJsonList: MutableList<JSONObject> = mutableListOf()

for (i in 0 until JSONArray.length()) {
    val currentJsonObject = JSONArray.getJSONObject(i)

    val newJsonObject = JSONObject().apply {
	jsonObject.put("nombreClave1", currentJsonObject.getTipoDato("nombreClave1"))
        jsonObject.put("nombreClave2", currentJsonObject.getTipoDato("nombreClave2"))
        jsonObject.put("nombreClaveN", currentJsonObject.getTipoDato("nombreClaveN"))    

    }
             

    objectJsonList.add(newJsonObject)
}


 

