

///////////////////////////////////////////////CRUD////////////////////////////////////////////////////////


DEFINICION DE CLASES ENTITY

Aquí todas las anotaciones como @Entity, @Id, @GeneratedValue(strategy = GenerationType.IDENTITY), entre
otras, se usan igual.

Las clases entity y dto deben ser data class. Una data class es una clase diseñada para almacenar o representar datos y no comportamiento. Kotlin genera automáticamente para ella: equals() (comparación por contenido), hashCode(), toString(), copy(), componentN() (usado para desestructuración como en js 
(val (a, b) = obj)). Esto lo puede hacer java con la anotación Loombok

Las anotaciones para validaciones o restricciones de atributos en Kotlin con Spring Boot funcionan igual
que en Java, pero la sintaxis cambia:
@field:NombreAnotacionRestriccion

@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
) ->
	La unica diferencia es que en el atributo id, se usas var porque se genera y se asigna automáticamente c	cuando guardas el objeto (no tienes que darlo tú).
	Es nullable (Long? = null) porque inicialmente no tiene valor, y solo la base de datos lo asignará.
	Es mutable (var) para que JPA pueda asignar el valor al guardar.

En Kotlin, no se necesita escribir manualmente los getters y setters como en Java. Kotlin los genera automáticamente cuando se define una propiedad.


CAPA DE REPOSITORY

La sintaxis para las interface es:

import com.alejandro.crudKotlin.entities.NombreEntidadX
import org.springframework.data.jpa.repository.JpaRepository

interface NombreEntidadXRepository : JpaRepository<NombreEntidadX, Long> {
    
}


CAPA DE SERVICE

La sintaxis para las interface es:

interface ActorService {

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

    fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, parN: tipoDatoN): tipoDatoReturn

}

Para las clases implementadoras:

@Service
class NombreClaseXServiceImpl(
    private val objetoXRepository: NombreClaseXRepository
) : NombreClaseXService {
    // contenido
} -> Define una clase implementadora llamada NombreEntidadXServiceImpl, implementará los métodos definidos 	en la interfaz NombreEntidadXService.
	Kotlin permite definir el constructor en la misma línea que la clase asi que, esta es la manera de
	inyectar una instancia del repositorio (gracias a @Service).

Los métodos mas o menos quedan: 

@Transactional
override fun nombreMetoHttpNombreOperacion1(par1: tipoDato1, par2: tipoDato2, 
	parN: tipoDatoN): tipoDatoReturn
{
        // contenido
}


CAPA DE CONTROLLER

@RestController
@RequestMapping("/api/arrayX")
class NombeEntidadXController(
    private val service: NombeEntidadX
) {}

El tipo de dato: ResponseEntity<?> es reemplazado por: ResponseEntity<*>.


///////////////////////////////////////////////OTROS//////////////////////////////////////////////////////


DEPURACION

import org.slf4j.Logger
import org.slf4j.LoggerFactory

private val log = LoggerFactory.getLogger(this::class.java) -> -> Para registrar mensajes de log en 
	la clase en la que está definido.


ANOTACIONES JSON


@JsonAlias("nombre1", "nombre2", "nombreN")
var nombreAtributoX: tipoDato = valorInicial -> El uso de esta anoptacion es sin el modo de acceso 
	private porque el modo de acceso tiene que ser public para que Jackson (u otras libs como Moshi) 	accedan directamente a las propiedades para deserializar.
	Ademas Kotlin genera automáticamente los getters y setters públicos.
	Esta anotación normalmente se usara en clases que representen un dto.

@get:JsonProperty("nombreAtributoXJson")
var nombreAtributoX: tipoDato = valoInicial -> Para que cuando se serialice este atributo, este atributo en
	el objeto json se llame: 'nombreAtributoXJson' y no 'nombreAtributoX'.


CREAR COMPONENTES/BEANS

En la raíz del proyecto se crea el paquete config/ y dentro de él una clase llamada AppConfig.

@Configuration
class AppConfig {} -> Pertmite definir beanes dentro de la clase.

@Bean
fun objetoBean(): NombreClaseBean {
   return NombreClaseBean()
} -> Crea un bean.


INYECCION DE DEPENDENCIAS

class NombreClaseZ(
    val nombreObjetoX: NombreComponenteX 
) -> Inyección por constructor. Esta es la manera mas recomendada en un proyecto de spring boot + kotlin.

@Autowired
lateinit var nombreObjetoX: NombreComponenteX -> Inyección por atributo. Como este atributo lo inicializa
	spring boot en tiempo de ejecución si no se pone el lateinit kotlin piensa que no tiene valor, 
	entonces se coloca eso para indicar que tomara un valor después (cuando spring boot lo 
	inicialice).


CONFIGURACION DEL CORS

En el package config/ crear una clase llamada: 'CorsConfig'.

@Configuration
class CorsConfig : WebMvcConfigurer {} -> Crea una clase de configuración para el cors.

override fun addCorsMappings(registry: CorsRegistry) {} -> Funcion para configurar al cors.

registry.addMapping("/api/**") -> Habilita el cors a todas estas rutas. 
	Todas las rutas que no esten aquí no se les habilitara el cors.

.allowedOrigins("*") -> Permite que cualquier origen (dominio ó IP y puerto) pueda hacer solicitudes CORS.
	- .allowedOrigins("http://ip_servidor:numPuerto") -> Permite que cualquier origen (IP y puerto) 		pueda hacer solicitudes CORS.
	- .allowedOrigins("http://url-fron") -> Permite que cualquier origen (domiio) pueda hacer 			solicitudes CORS.

.allowedMethods("*") -> Indica que permite todo tipo de métodos http sean consumidos.
	- .allowedMethods("NOMBRE_METODO_HTTP", "NOMBRE_METODO_HTTP", "NOMBRE_METODO_HTTP") -> Para
		que solo se permitan ciertos metodos http.

.allowCredentials(true) -> Para poder recibir cookies y hearders de autenticacion.
	Comunmente usado cuando se impementa spring security.

Wildcards en addMapping -----------------------------

/api/* -> Toma cualquier valor en un único sub nivel siguiente.
	Entonces si tenemos las rutas /api/uno, /api/dos, /api/tres y /api/cuatro/cinco y aplicamos /api/* 	en addMapping, se aplicaria a todas las rutas menos a /api/cuatro/cinco porque tiene dos subniveles
	siguientes después de /api/.

/api/** -> Se aplica a cualquier cantidad de subrutas dentro de api.
	Por ejemplo a /api/uno, /api/cuatro/cinco y /api/seis/siete/ocho.

/api/*/sub-nivel-dos -> Para que tome cualquier valor en el subnivel que esta entre el 1 y 3.
	Esta forma es útil cuando tenemos un @RequestMapping con @PathVariable como por ejemplo:
	@RequestMapping("/v4/{business}/clupp-CAR") porque .addMapping(...), NO puede interpretar los {} 	como tal @RequestMapping. *******



POR DEFINIR EL NOMBRE

Si un json esta conformado por un buen de objetos, las claess que representan a esos objetos se 
definen en la misma clase.

Ws: Web service. Es un DTO (Data Transfer Object) usado para recibir datos desde un servicio externo (o enviarlos).
Se pone como postfijo a una clase.

///////////////////////////////////////////////CLIENTES//////////////////////////////////////////////////


REST TEMPLATE
	
Incluida en la dependencia: spring-boot-starter-web.

Crear el paquete llamado config/ y dentro de este una clase de configuración, ahí crear el bean para
restTemplate.

@Configuration
class AppConfig {

    @Bean
    fun restTemplate(): RestTemplate {
        return RestTemplate()
    }

} -> declararlo como un @Bean a restTemplate.


En una clase service ---------------------------------------------

Inyectar el componenete por medio de autowired o constructor primario.

@Service
class NombreClaseXServicio(private val restTemplate: RestTemplate) {}

val headers = HttpHeaders() -> Permite la definición del header.

headers.accept = listOf(MediaType.APPLICATION_JSON) -> Para indicar que esperamos el cuerpo de la respuesta 	que da el servidor en formato json.

headers.setBearerAuth("token") -> Para agregar el token de autorización de tipo Bearer que necesita la
	petición.

val entity = HttpEntity<String>("", headers) -> Crea un objeto HttpEntity que encapsula dos cosas:
	El cuerpo (body) de la solicitud y los encabezados.

val response = restTemplate.exchange(
    url,
    HttpMethod.NOMBRE_METODO_HTTP,
    entity,
    NombreTipoDato
) -> Realiza cierta petición a un servidor.


°°°°° Método de JSONArray °°°°°°°

val lista: MutableList<JSONObject> = mutableListOf() -> Crea una lista mutable vacía que almacenará 
	objetos de tipo json.

arregloJson.getJSONObject(i) -> Del arreglo de objetos json devuelve el objeto JSON que está en la 
	posición i.

JSONArray(lista) -> Convierte una lista de JSONObject en un JSONArray.


°°°°° Método de JSONObject °°°°°°°

JSONObject(response.body) -> Convierte un json string a un objeto json.

objetoJson.getJSONArray("nombreClave") -> Accede a determinado atributo o clave del objeto json.

val objetoJson = JSONObject() -> Crea un objeto json.

objetoJson.put("Id", Id) -> Crea una clave y le asigna un valor dentro de un objeto json.

objetoJson.getTipoDatoY("nombreClaveX") -> Dentro del objeto json busca y extrae el valor asociado a 
	cierto clave (atributo)	y la convierte al tipo de dato ye.
	Si no encuentra el atributo o no es un valor casteable lanzara null pointer exception.

objetoJson.optTipoDatoY("nombreClaveX", valorDefecto) -> Dentro del objeto json busca y extrae el valor 	asociado a cierto clave (atributo) y la convierte al tipo de dato ye.
	Si no encuentra el atributo o no es un valor casteable devuelve el valor por defecto.


°°°°° Extraer determinados valores de una arreglo obtener un nuevo arreglo °°°°°°°

val response = restTemplate.exchange(
    url,
    HttpMethod.NOMBRE_METODO_HTTP,
    entity,
    String::class.java // obligatorio
)

val JSONArray = JSONObject(resp.body)

val objectJsonList: MutableList<JSONObject> = mutableListOf()

for (i in 0 until JSONArray.length()) {
    val currentJsonObject = JSONArray.getJSONObject(i)

    val newJsonObject = JSONObject().apply {
	jsonObject.put("nombreClave1", currentJsonObject.getTipoDato("nombreClave1"))
        jsonObject.put("nombreClave2", currentJsonObject.getTipoDato("nombreClave2"))
        jsonObject.put("nombreClaveN", currentJsonObject.getTipoDato("nombreClaveN"))    

    }
             

    objectJsonList.add(newJsonObject)
}


 

