@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
) ->
	La unica diferencia es que en el atributo id, se usas var porque se genera y se 
	asigna automáticamente cuando guardas el objeto (no tienes que darlo tú).
	Es nullable (Long? = null) porque inicialmente no tiene valor, y solo la base de 
	datos lo asignará.
	Es mutable (var) para que JPA pueda asignar el valor al guardar.

Lo malo de kotlin es que para instanciar objetos de clases entity es necesario pasarle valores a todos
los atributos, incluyendo al id aunque este lo genere automáticamente jpa, lo común es asignarle el 0.
U otra alternativa es usar named arguments, cuando se instancie un objeto se debe especificar a que atributo
va cada valor y en este caso se omitiría el nombre del atributo id.

val objetoX = NombreClaseX(
    nombreAtributo1 = valor1,
    nombreAtributo2 = valor2,
    nombreAtributoN = valorN,
)



///// OTROS ///////////////////////////////////////////////////

CONSULTAS NATIVAS

Es cuando en un método dentro de una clase repositorio hace una consulta personalizada usando la anotación
query y usando sql nativo (la sintaxis de sql y no la jpql).
Hacerlo de esto modo tiene la característica que el resultado será de tipo 'TupleBackedMap' (resultado genérico de una consulta nativa).

Para convertir el resultado de una consulta nativa a un objeto java hay varias formas: 1. si el objeto de 
retorno coincide con un objeto de una clase entity, en este caso spring boot hará la conversión 
automáticamente 2. si el objeto de retorno debe ser un dto, se deben aplicar diversas técnicas.

Convertir el objeto de retorno de una consulta nativa a un dto -----------------------------------

Se debe hacer un mapeo explícito con: @SqlResultSetMapping, @ConstructorResult, proyección de interfaz o constructor expresivo en JPQL.

°°°°°°°° Usando proyección °°°°°°°

Esta forma se usa cuando el dto nunca se necesita para instanciar objetos en todo el proyecto, solo se
ocupara para cachar lo que retornan las consultas nativas.

interface NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
} -> Cambiar la clase dto por una interface.
	Si se define un DTO como interfaz, Spring hace el mapeo por nombre de columnas, entonces las
	queries deben devolver las columnas con los mismos nombres de atributos de la interface dto.


°°°°°°°° Usando proyección + clase dto °°°°°°°

Esta forma se usa cuando el dto se necesita para instanciar objetos en alguna parte del proyecto y mas
aparte se necesita la proyección para cachar lo que retornan las consultas nativas.
 
*se crea la proyección*

data class NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
}

*En un método de servicio*
*Al usar un método repositorio que hace la consulta nativa*
objetoXRepository.nombreMetodoX().map {
        NombreClaseDto(it.nombreAtributo1, it.nombreAtributo2, it.nombreAtributoN)
} -> se debe convertir el resultado a la clase dto.


ENTITY MANAGER
 
Es una alternativa a usar las operaciones que brinda una clase repository que implmenta el Spring Data de jpa.
Se usa en consultas dinámicas donde el nombre de la tabla o campos cambian, porque en las consultas de jpa 
solo se puede cambiar dinámicamente el valor que se le pasan a los campos y no el nombre de tablas o 
campos. ******

Se crea una clase llamada: NombreClaseXRepository y se le inyecta el objeto entityManager.

@Repository
class NombreClaseXRepository(
    @PersistenceContext private val entityManager: EntityManager
) {...} -> Crea una clase y la vuelve un componente de spring boot.
	Inyecta el objeto entityManager el cual sirve para ejecutar consultas JPQL o nativas y Persistir o 
	eliminar entidades.

*Dentro de algun metodo*

val sql = """
            sentencia sql
        """.trimIndent() -> Se crea un string el cual contiene a la operación sql a realizar.

Crear queries ----------------------------------

val query = entityManager.createNativeQuery(sql) -> Crea un objeto Query que representa la consulta
	a realizar (No ejecuta nada todavía).
	La variable sql contiene una operación de sql nativa. ***

val query = entityManager.createQuery(sql, NombreClaseEntidadX::class.java) -> Crea un objeto Query que 	representa la consulta a realizar (No ejecuta nada todavía).
	La variable sql contiene una operación de sql nativa. ***
	El resultado se mapeara automáticamente a entidades JPA.

query.setParameter("paramName", valor) -> Para inyectar valores a nivel (WHERE), SET en UPDATE, INSERT.
	No funciona para inyectar el nombre de tablas. ****
	En la consulta sql iría algo como: ':paramName' y para inyectar ese valor seria con esta 
	instrucción.  
	
Para ejecutar consultas ------------------------

query.getResultList() → Ejecuta la consulta y devuelve una lista de resultados.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.resultList as List<Array<Any>>
	  return result.map {
    		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		)
	  } -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
		el arreglo de filas en una lista de objetos dto.
		- cols[0].toString() -> Esta seria la manera de convertir un campo que contiene un 
			valor diferente de string a string (pe convertir un int, bigInt, etc a string).

query.getSingleResult() → Ejecuta la consulta y devuelve un solo resultado.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.singleResult as Array<Any>
		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		) -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
			la fila en un objeto dto.

query.executeUpdate() → Para insert, update o delete (no devuelve filas).


Se tuvo la situación de que se particiono una tabla mediante la técnica de partición por catálogos, de 
tal modo que se tenia una tabla llamada extracción y contenía datos de todos los vehículos pero había
muchos tipos de vehículos asi que se creo una tabla para cada tipo de vehiculo obteniendo las tablas:
extraccion_auto, extraccion_tractocamion y extracción_pickup. Cada una de estas 3 tablas evidentmente
tenían la misma estructura que la tabla original (tabla extraccion).
Entonces al hacer este cambio las consultas que habían originalmente quedaron totalmente igual pero ahora
había que cambiar dinamicamnete el nombre de la tabla para que apuntara de acuerdo al tipo de camión
buscado. Entonces para eso se uso entity manager.



//////AVANZADO //////

CIFRADO Y DESCIFRADO DE DATOS

Utilizado para cifrar llaves y credenciales, tambien para cifrar tokens.

Teoría ------------------------------------------------------

Initialization Vector (IV): es un valor ALEATORIO que asegura que un mismo texto al ser cifrado con la misma
llave se obtenga siempre un diferente resultado.
Un IV siempre debe ser:
 	ÚNICO: Nunca reusar el mismo IV con la misma clave
	ALEATORIO: Debe ser impredecible (usar SecureRandom).

Tamaño del iv según el algoritmo:
Algoritmo	Tamaño de bloque	Tamaño de IV requerido
AES	        128 bits (16 bytes)	16 bytes
DES	        64 bits (8 bytes)	8 bytes
3DES	       64 bits (8 bytes)	8 bytes
Blowfish	64 bits (8 bytes)	8 bytes

Aes
Longitudes:
Tamaño	       Bits	Intentos para romper	Tiempo estimado
16 bytes	128	2¹²⁸	Billones de años
24 bytes	192	2¹⁹²	Edad del universo
32 bytes	256	2²⁵⁶	Múltiples edades del universo


Flujos --------------------------------------------------

Cifrado:
	Generar IV aleatorio nuevo
	Cifrar texto con clave + IV aleatorio
	Concatenar: IV_aleatorio + texto_cifrado
	Devolver todo en Base64

Descifrar:
	Separar IV y texto cifrado
	Descifrar con clave + IV recibido
	Devolver texto plano
	

Configuraciones -----------------------------------------

Se crea un application llamado: application-secrets. Aquí se depositan la llave que se usa para cifrar y 
descifrar (secretKey) y otras claves y valores sensibles.

*En application-secrets*
 clave1: valor1
 clave2: valor2
 claveN: valorN 

*En application-default*
spring.profiles.include=secrets -> Le dice a Spring que active el perfil "secrets" ADEMÁS de los perfiles
	ya activos.
	De esta manera es como si esta configuraciones se incluyen automáticamente en todos los entornos.


En utils/crypto/ ---------------------------------------

Crear la clase que genera la llave que va en application-secrets.

°°°°°°°°° KeyGeneratorUtil °°°°°°°°°°

// Para poder generar una nueva llave de cifrado cada que asi se necesite
object KeyGeneratorUtil {

    @Throws(Exception::class)
    fun generarClaveSecreta(tamanio: Int): Map<String, String> {
        require(tamanio == 16 || tamanio == 24 || tamanio == 32) {
            "Tamaño debe ser 16, 24 o 32"
        }

        val keyGen = KeyGenerator.getInstance("AES")
        keyGen.init(tamanio * 8)
        val secretKey = keyGen.generateKey()
        val claveBase64 = Base64.getEncoder().encodeToString(secretKey.encoded)

        return mapOf(
            "base64" to claveBase64,
            "string" to String(Base64.getDecoder().decode(claveBase64), Charsets.UTF_8),
            "tamanio" to tamanio.toString(),
            "bits" to (tamanio * 8).toString()
        )
    }

    fun generarLlavesCompletas(tamanioClave: Int = 32): Map<String, Any> {
        val clave = generarClaveSecreta(tamanioClave)

        return mapOf(
            "clave" to clave,
            "yamlConfig" to """
                crypto:
                  secret-key: "${clave["string"]}"
                  algorithm: "AES/CBC/PKCS5Padding"
                  key-algorithm: "AES"
            """.trimIndent()
        )
    }

}

Crear un Controller que llama a la función generarLlavesCompletas() y la llave colocarla en el
application-secrets.
De todos los valores que retorna la función, la llave vendría a ser la correspondiente al atributo base64.

Generar el servicio de cifrado y descifrado.


°°°°°°°°° CryptoUtil °°°°°°°°°°

Se convierte la clase en un componenete de spring boot.

*Donde se crean los atributos de clase*
 private var algorithm: String = "AES/CBC/PKCS5Padding"
 private var keyAlgorithm: String = "AES"

 @Value("\${secretKey}")
 private var secretKey: String = ""


// Decodifica Base64 si es posible, sino usa el string como está
    private fun decodeBase64OrString(input: String): ByteArray {
        return try {
            // Intenta decodificar como Base64
            Base64.getDecoder().decode(input)
        } catch (e: Exception) {
            print(e.message)
            // Si falla, usa el string como bytes UTF-8
            input.toByteArray(Charsets.UTF_8)
        }
    }

// Cache para los bytes decodificados
    private val secretKeyBytes: ByteArray by lazy {
        decodeBase64OrString(secretKey)
    }

    fun cifrar(texto: String): String {
        try {
            // Validar que las llaves estén configuradas
            validarConfiguracion()

            // Crear la clave secreta desde bytes decodificados
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // 🎲GENERAR IV ALEATORIO (nuevo por cada cifrado)
            val ivAleatorio = ByteArray(16)
            SecureRandom().nextBytes(ivAleatorio)
            val ivParameterSpec = IvParameterSpec(ivAleatorio)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)

            // Cifrar el texto
            val textoCifrado = cipher.doFinal(texto.toByteArray(Charsets.UTF_8))

            // Devolver: IV_aleatorio + texto_cifrado (ambos en Base64)
            return Base64.getEncoder().encodeToString(ivAleatorio) + ":" +
                    Base64.getEncoder().encodeToString(textoCifrado)

        } catch (e: Exception) {
            throw Exception("Error al cifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para cifrar.

private fun validarConfiguracion() {
        if (secretKey.isBlank()) {
            throw IllegalStateException("La clave secreta no está configurada")
        }
    } -> Funcion para validar que exista la llave para cifrar y descrifrar.

fun descifrar(textoCifradoCompleto: String): String {
        try {
            // Validar que las llaves estén configuradas
            validarConfiguracion()

            // SEPARAR IV y texto cifrado (formato: "IV_base64:texto_base64")
            val partes = textoCifradoCompleto.split(":")
            if (partes.size != 2) {
                throw IllegalArgumentException("Formato inválido. Debe ser: IV_base64:textoCifrado_base64")
            }

            val ivDecodificado = Base64.getDecoder().decode(partes[0])
            val textoCifradoDecodificado = Base64.getDecoder().decode(partes[1])

            // Crear la clave secreta
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // Crear el vector de inicialización desde el IV recibido
            val ivParameterSpec = IvParameterSpec(ivDecodificado)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec)

            // Descifrar el texto
            val textoDescifrado = cipher.doFinal(textoCifradoDecodificado)

            return String(textoDescifrado, Charsets.UTF_8)

        } catch (e: Exception) {
            throw Exception("Error al descifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para descifrar.

En el mismo controller, crear endpoints que llamen a la funciónes para cifrar y descifrar.



CREAR CLASE PARA INYECTAR VALORES 

@Configuration
@ConfigurationProperties(prefix = "clavePrincipal")
class CryptoConfig {
    var nombreAtributo1: String = ""
    var nombreAtributo2: String = ""
    var nombreAtributoN: String = ""
} -> Para crear una clase que contiene puros atributos, los cuales almacenaran valores de un
	application-personalizado.
	- @ConfigurationProperties(prefix = "clavePrincipal") -> Busca en el application default y despues 		busca en el application activo y al final busca en otros application extra activos las 
		claves que empiencen con el nombre clavePrincipal. 
		Se debe considerar que los valores se pueden sobreescribir, de tal modo que el ultimo 			application en escribir el valor para una clave, se tomara ese valor. **

*En un application*
clavePrincipal:
    clave1: valor1
    clave2: valor2
    claveN: valorN 



/////////////////////////MONGODB CON SPRING BOOT////////////////////////////////////////


TEORIA PARA SPIRNG DATA MONGODB

Cuando insertas el primer documento en una collection que no existe, MongoDB crea la collection automáticamente en ese momento asi que No hay necesidad de crear collections explícitamente.
Es por eso que cuando se trabaja con mongoDb no existe la configuración ddl-auto=valor.


CONFIGURACIONES CON MONGODB

logging.level.org.springframework.data.mongodb=DEBUG
logging.level.org.mongodb=DEBUG -> Para ver con detalle las operaciones que se hacen en mongoDb.
	Equivalente a la instrucción: 'spring.jpa.properties.hibernate.show-sql=true'. *****
	En los logs se vera información como:
		Operaciones de find (consultas)
		Inserts de documentos
		Updates y modificaciones
		Delete operations
		Aggregations y pipelines
		Conexiones y comandos enviados al servidor MongoDB
	Estos valores se usan para el perfil de dev por que son bansante detallados para prod se usaría:
	INFO y WARN para esas dos instrucciones respectivamtne.

logging.level.org.mongodb.driver.cluster=INFO -> Para no mostrar los logs que son de monitoreo del 
	cluster de MongoDB.
	Si no se ocultan, a cada rato se mostraran mensajes de MongoDB Driver que hace para verificar el 	estado del servidor.
	
spring.data.mongodb.auto-index-creation=true -> crea automáticamente índices definidos con @Indexed en 
	las collections.


CLASES ENTITY CON MONGODB

@Field -> Únicamente sirve para indicar el nombre que tiene el atributo en el campo de la collecion y 
	no tiene mas configuraciones. ****
	Nunca apliarselo al campo id porque mongoDb siempre necesita que el campo se llame id para 	identificador primario. ***************

@Indexed() -> Sirve para crear índices.
	- name = "idx_nombre_indice" -> Para darle un nombre al indice.
	- direction = IndexDirection.DESCENDING -> Indica que el ordenamiento sera descendente.


Alternativa a columnDefinition de spring data jpa ------------------------

Cuando se tienen un campo en una tabla con cierto tipo de dato pero en el código se quiere trabajar con 
ese mismo campo pero con otro tipo de dato, se suele usar la configuración columnDefinition de la anotación
@Column, pero en mongoDb eso no existe.
Pe se ha tenido la situación de tener un campo int en una tabla pero en el código se desea trabajar como
si ese campo fuera de tipo string (varchar).

Para lograr el mismo efecto en con spring data mongoDb se agrega el siguiente código:

data class Extraccion (
    private var _claveInt: Int = 0
) {

    var clave: String
        get() = _claveInt.toString()
        set(value) { _claveInt = value.toIntOrNull() ?: 0 }

    var marca: String = ""

    var submarca: String = ""
} -> De esta manera solo un campo (el campo clave) se trata como si fuera string en el código pero en 
	la tabla es int y los demás atributos se tratan de manera normal.
	Observese que los campos no se definen en () si no dentro de {}. *********


REPOSITORIES CON MONGODB

interface NombreEntidadXRepository : MongoRepository<NombreEntidadX, TipoDatoId> {
    // métodos personalizados
} -> Para hacer operaciones CRUD + queries personalizadas sobre la entidad NombreEntidadX.
	Para que MongoRepository funcione, la clase NombreEntidadX debe ser una clase con la cual tiene 
	un campo marcado con @Id. ****
	Spring Data se encarga de detectar todas las interfaces que extienden MongoRepository (o 
	JpaRepository, CrudRepository, etc.) gracias al mecanismo de repository scanning. Al arrancar 
	la aplicación, Spring genera un bean automático para esa interface. *****


Consultas personalizadas con @Query -----------------------------

@Query(value = "{}", 
	fields = "{ '_id': 1, 'nombreCampo1': valor, 'nombreCampo2': valor, 'nombreCampoN': valor}")
fun nombreFuncion(): tipoDatoRetorno
	Lo malo de usar esta forma es que si o si se consulta la tabla (collection), que envuelve la
	interace 'MongoRepository'.
	- fileds -> Sirve para incluir o exluir campos segun sea su valor.
		Es como ponerlos o no en el select. ****
		Si no se pone al campo: _id, se incluye automáticamente, pero Si lo pones con 0, lo 
		excluyes explícitamente. ****
		Posibles valores:
		- 1 incluye el campo en la salida de la consulta.
		- 0 excluye el campo de la salida.
	- value -> define qué documentos se quieren traer (como un filtro → equivalente al WHERE en SQL).
		Ejemplos:
		- value = "{ 'country': 'MX' }" → filtra solo documentos donde country = "MX".


Consultas personalizadas con MongoTemplate -----------------------------

El objeto MongoTemplate en Spring Data MongoDB permite armar queries dinámicas y hasta cambiar el nombre de la tabla/colección en runtime (similar a entityManager).

°°°°°°°°°° Manera 1 °°°°°°°°°

Manera cuando se hacen operaciones simples.

import org.springframework.data.mongodb.core.query.Query // De este paquete.

*Dentro de un metodo*

val query = Query() -> Crea un objeto query representa la consulta MongoDB que vas a ejecutar con 
	MongoTemplate.

query.fields().include("nombreCampo1", "nombreCampo2", "nombreCampoN") -> Determina que campos nos queremos
	traer.
	Es como el select de sql. ***+

val results = mongoTemplate.find(query, Map::class.java, collectionName) -> Ejecuta la consulta preparada.
	Se indica el nombre de la colleccion a la cual se aplicara la consulta y el nombre de la clase que
	representa tipo de dato que retornara la consulta.
	El nombre de la clase que representa el tio de dato que retonrar la consulta siempre será map,
	después con ese mapa se mapeara a una clase de interés.

val list: List<NombreClaseDto> = results.map { document ->
    NombreClaseDto(
        nombreAtributo1 = document["nombreCampo1"].toString(),
        nombreAtributo2 = document["nombreCampo2"].toString(),
	nombreAtributoN = document["nombreCampoN"].toString(),
    )
}.toList() -> Manerar de mapear lo que contiene un mapa hacia una clase dto. ****


°°°°°°°°°° Manera 2 °°°°°°°°°

Se usa cuando necesitas pipeline avanzado, como:
distinct
group by
count
operaciones de agregación (sum, avg, etc.)
transformar/renombrar campos

import org.springframework.data.mongodb.core.aggregation.Aggregation
import org.springframework.data.mongodb.core.query.Criteria
import org.springframework.data.domain.Sort // De estos pquetes

val aggregation = Aggregation.newAggregation() -> Prepara un consulta.
	Instrucciones que puede recibir.
	- Aggregation.group("nombreCampo") -> Agrupa por determinado campo.
		Cuando se agrupa por múltiples campos, MongoDB los almacena en el objeto llamado '_id'.***
	- Aggregation.sort(Sort.by(Sort.Direction.DESC/ASC, "nombreCampo")) -> Para ordenar asc o desc por
		determinado campo.
	- Aggregation.limit(n) -> Para indicar un limite de resultados.
	- Aggregation.match() -> Para crear filtros.
		condiciones:
		- Criteria.where("marca").`is`(marca)
        	  .and("activo").`is`(true)
        	  .and("stock").gt(0) -> Ejemplo de puros ands.
		- Criteria().orOperator(
        	 	Criteria.where("categoria").`is`("electronicos"),
       			Criteria.where("categoria").`is`("electrodomesticos")
    		  ) -> Ejemplo de puro or.

		Operadores:
			- .lt(1000) -> Menor que
        		- .gte(50) -> Mayor o igual que  
        		- .lte(500) -> Menor o igual que
        		- .`in`(listOf("A", "B", "C")) -> En una lista
        		- .ne("null") -> No igual
        		- .regex("^Nike") -> Expresión regular
	- Aggregation.count().as("total") -> Para hacer un conteo.
	- Aggregation.project() -> Transforma la estructura de salida.
		Metodos que encadenan a esta instrucción: 
		- .and("nombreCampo").as("nuevoNombreCampo") -> Renombra determinado campo
		- .andExclude("campo") -> Para Excluir campo.
    		- .andInclude("campo") -> Para Incluir campo
		- .andExpression("precio * cantidad").as("total") -> Hacer operaciones con los campos.

Se supone que el orden de las clausulas: where, select, distinc, group by es indiferente, sin embargo, se 
tuvieron diversos problemas al usuarlos en un orden culqaquiera. Tomando diversas consultas exitosas se
determino que el orden correcto para usar esas clausulas es: match (para hacer condiciones como el where),
group, Project y al final sort. ********

val results = mongoTemplate.aggregate(
    aggregation,
    nombreCollection,
    Map::class.java
).mappedResults -> Ejecuta una consulta de agregación.
	Al igual que la manera anterior, siempre se usa map y ya después se mapea hacia la clase de interés.

val list: List<NombreClaseDto> = results.map { document ->
    NombreClaseDto(
        nombreAtributo1 = document["nombreCampo1"].toString(),
        nombreAtributo2 = document["nombreCampo2"].toString(),
	nombreAtributoN = document["nombreCampoN"].toString(),
    )
}.toList() -> Manerar de mapear lo que contiene un mapa hacia una clase dto. ****



