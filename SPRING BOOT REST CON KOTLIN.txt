@Entity
data class NombreClaseX(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null

    var nombreAtributo1: tipoDato,
    var nombreAtributo2: tipoDato,
    var nombreAtributoN: tipoDato,
) ->
	La unica diferencia es que en el atributo id, se usas var porque se genera y se 
	asigna automÃ¡ticamente cuando guardas el objeto (no tienes que darlo tÃº).
	Es nullable (Long? = null) porque inicialmente no tiene valor, y solo la base de 
	datos lo asignarÃ¡.
	Es mutable (var) para que JPA pueda asignar el valor al guardar.

Lo malo de kotlin es que para instanciar objetos de clases entity es necesario pasarle valores a todos
los atributos, incluyendo al id aunque este lo genere automÃ¡ticamente jpa, lo comÃºn es asignarle el 0.
U otra alternativa es usar named arguments, cuando se instancie un objeto se debe especificar a que atributo
va cada valor y en este caso se omitirÃ­a el nombre del atributo id.

val objetoX = NombreClaseX(
    nombreAtributo1 = valor1,
    nombreAtributo2 = valor2,
    nombreAtributoN = valorN,
)



///// OTROS ///////////////////////////////////////////////////

CONSULTAS NATIVAS

Es cuando en un mÃ©todo dentro de una clase repositorio hace una consulta personalizada usando la anotaciÃ³n
query y usando sql nativo (la sintaxis de sql y no la jpql).
Hacerlo de esto modo tiene la caracterÃ­stica que el resultado serÃ¡ de tipo 'TupleBackedMap' (resultado genÃ©rico de una consulta nativa).

Para convertir el resultado de una consulta nativa a un objeto java hay varias formas: 1. si el objeto de 
retorno coincide con un objeto de una clase entity, en este caso spring boot harÃ¡ la conversiÃ³n 
automÃ¡ticamente 2. si el objeto de retorno debe ser un dto, se deben aplicar diversas tÃ©cnicas.

Convertir el objeto de retorno de una consulta nativa a un dto -----------------------------------

Se debe hacer un mapeo explÃ­cito con: @SqlResultSetMapping, @ConstructorResult, proyecciÃ³n de interfaz o constructor expresivo en JPQL.

Â°Â°Â°Â°Â°Â°Â°Â° Usando proyecciÃ³n Â°Â°Â°Â°Â°Â°Â°

Esta forma se usa cuando el dto nunca se necesita para instanciar objetos en todo el proyecto, solo se
ocupara para cachar lo que retornan las consultas nativas.

interface NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
} -> Cambiar la clase dto por una interface.
	Si se define un DTO como interfaz, Spring hace el mapeo por nombre de columnas, entonces las
	queries deben devolver las columnas con los mismos nombres de atributos de la interface dto.


Â°Â°Â°Â°Â°Â°Â°Â° Usando proyecciÃ³n + clase dto Â°Â°Â°Â°Â°Â°Â°

Esta forma se usa cuando el dto se necesita para instanciar objetos en alguna parte del proyecto y mas
aparte se necesita la proyecciÃ³n para cachar lo que retornan las consultas nativas.
 
*se crea la proyecciÃ³n*

data class NombreClaseDto {
    val nombreAtributo1: tipoDato1
    val nombreAtributo2: tipoDato2
    val nombreAtributoN: tipoDatoN
}

*En un mÃ©todo de servicio*
*Al usar un mÃ©todo repositorio que hace la consulta nativa*
objetoXRepository.nombreMetodoX().map {
        NombreClaseDto(it.nombreAtributo1, it.nombreAtributo2, it.nombreAtributoN)
} -> se debe convertir el resultado a la clase dto.


ENTITY MANAGER
 
Es una alternativa a usar las operaciones que brinda una clase repository que implmenta el Spring Data de jpa.
Se usa en consultas dinÃ¡micas donde el nombre de la tabla o campos cambian, porque en las consultas de jpa 
solo se puede cambiar dinÃ¡micamente el valor que se le pasan a los campos y no el nombre de tablas o 
campos. ******

Se crea una clase llamada: NombreClaseXRepository y se le inyecta el objeto entityManager.

@Repository
class NombreClaseXRepository(
    @PersistenceContext private val entityManager: EntityManager
) {...} -> Crea una clase y la vuelve un componente de spring boot.
	Inyecta el objeto entityManager el cual sirve para ejecutar consultas JPQL o nativas y Persistir o 
	eliminar entidades.

*Dentro de algun metodo*

val sql = """
            sentencia sql
        """.trimIndent() -> Se crea un string el cual contiene a la operaciÃ³n sql a realizar.

Crear queries ----------------------------------

val query = entityManager.createNativeQuery(sql) -> Crea un objeto Query que representa la consulta
	a realizar (No ejecuta nada todavÃ­a).
	La variable sql contiene una operaciÃ³n de sql nativa. ***

val query = entityManager.createQuery(sql, NombreClaseEntidadX::class.java) -> Crea un objeto Query que 	representa la consulta a realizar (No ejecuta nada todavÃ­a).
	La variable sql contiene una operaciÃ³n de sql nativa. ***
	El resultado se mapeara automÃ¡ticamente a entidades JPA.

query.setParameter("paramName", valor) -> Para inyectar valores a nivel (WHERE), SET en UPDATE, INSERT.
	No funciona para inyectar el nombre de tablas. ****
	En la consulta sql irÃ­a algo como: ':paramName' y para inyectar ese valor seria con esta 
	instrucciÃ³n.  
	
Para ejecutar consultas ------------------------

query.getResultList() â†’ Ejecuta la consulta y devuelve una lista de resultados.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.resultList as List<Array<Any>>
	  return result.map {
    		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		)
	  } -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
		el arreglo de filas en una lista de objetos dto.
		- cols[0].toString() -> Esta seria la manera de convertir un campo que contiene un 
			valor diferente de string a string (pe convertir un int, bigInt, etc a string).

query.getSingleResult() â†’ Ejecuta la consulta y devuelve un solo resultado.
	- @Suppress("UNCHECKED_CAST")
	  val result = query.singleResult as Array<Any>
		NombreClaseDto(
        	   nombreAtributo1 = it[0] as tipoDato1,
        	   nombreAtributo2 = it[1] as tipoDato2,
		   nombreAtributoN = it[n] as tipoDatoN
    		) -> Si se da el caso en el que la consulta fue nativa, esta es la manera para convertir 
			la fila en un objeto dto.

query.executeUpdate() â†’ Para insert, update o delete (no devuelve filas).


Se tuvo la situaciÃ³n de que se particiono una tabla mediante la tÃ©cnica de particiÃ³n por catÃ¡logos, de 
tal modo que se tenia una tabla llamada extracciÃ³n y contenÃ­a datos de todos los vehÃ­culos pero habÃ­a
muchos tipos de vehÃ­culos asi que se creo una tabla para cada tipo de vehiculo obteniendo las tablas:
extraccion_auto, extraccion_tractocamion y extracciÃ³n_pickup. Cada una de estas 3 tablas evidentmente
tenÃ­an la misma estructura que la tabla original (tabla extraccion).
Entonces al hacer este cambio las consultas que habÃ­an originalmente quedaron totalmente igual pero ahora
habÃ­a que cambiar dinamicamnete el nombre de la tabla para que apuntara de acuerdo al tipo de camiÃ³n
buscado. Entonces para eso se uso entity manager.



//////AVANZADO //////

CIFRADO Y DESCIFRADO DE DATOS

Utilizado para cifrar llaves y credenciales, tambien para cifrar tokens.

TeorÃ­a ------------------------------------------------------

Initialization Vector (IV): es un valor ALEATORIO que asegura que un mismo texto al ser cifrado con la misma
llave se obtenga siempre un diferente resultado.
Un IV siempre debe ser:
 	ÃšNICO: Nunca reusar el mismo IV con la misma clave
	ALEATORIO: Debe ser impredecible (usar SecureRandom).

TamaÃ±o del iv segÃºn el algoritmo:
Algoritmo	TamaÃ±o de bloque	TamaÃ±o de IV requerido
AES	        128 bits (16 bytes)	16 bytes
DES	        64 bits (8 bytes)	8 bytes
3DES	       64 bits (8 bytes)	8 bytes
Blowfish	64 bits (8 bytes)	8 bytes

Aes
Longitudes:
TamaÃ±o	       Bits	Intentos para romper	Tiempo estimado
16 bytes	128	2Â¹Â²â¸	Billones de aÃ±os
24 bytes	192	2Â¹â¹Â²	Edad del universo
32 bytes	256	2Â²âµâ¶	MÃºltiples edades del universo


Flujos --------------------------------------------------

Cifrado:
	Generar IV aleatorio nuevo
	Cifrar texto con clave + IV aleatorio
	Concatenar: IV_aleatorio + texto_cifrado
	Devolver todo en Base64

Descifrar:
	Separar IV y texto cifrado
	Descifrar con clave + IV recibido
	Devolver texto plano
	

Configuraciones -----------------------------------------

Se crea un application llamado: application-secrets. AquÃ­ se depositan la llave que se usa para cifrar y 
descifrar (secretKey) y otras claves y valores sensibles.

*En application-secrets*
 clave1: valor1
 clave2: valor2
 claveN: valorN 

*En application-default*
spring.profiles.include=secrets -> Le dice a Spring que active el perfil "secrets" ADEMÃS de los perfiles
	ya activos.
	De esta manera es como si esta configuraciones se incluyen automÃ¡ticamente en todos los entornos.


En utils/crypto/ ---------------------------------------

Crear la clase que genera la llave que va en application-secrets.

Â°Â°Â°Â°Â°Â°Â°Â°Â° KeyGeneratorUtil Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°

// Para poder generar una nueva llave de cifrado cada que asi se necesite
object KeyGeneratorUtil {

    @Throws(Exception::class)
    fun generarClaveSecreta(tamanio: Int): Map<String, String> {
        require(tamanio == 16 || tamanio == 24 || tamanio == 32) {
            "TamaÃ±o debe ser 16, 24 o 32"
        }

        val keyGen = KeyGenerator.getInstance("AES")
        keyGen.init(tamanio * 8)
        val secretKey = keyGen.generateKey()
        val claveBase64 = Base64.getEncoder().encodeToString(secretKey.encoded)

        return mapOf(
            "base64" to claveBase64,
            "string" to String(Base64.getDecoder().decode(claveBase64), Charsets.UTF_8),
            "tamanio" to tamanio.toString(),
            "bits" to (tamanio * 8).toString()
        )
    }

    fun generarLlavesCompletas(tamanioClave: Int = 32): Map<String, Any> {
        val clave = generarClaveSecreta(tamanioClave)

        return mapOf(
            "clave" to clave,
            "yamlConfig" to """
                crypto:
                  secret-key: "${clave["string"]}"
                  algorithm: "AES/CBC/PKCS5Padding"
                  key-algorithm: "AES"
            """.trimIndent()
        )
    }

}

Crear un Controller que llama a la funciÃ³n generarLlavesCompletas() y la llave colocarla en el
application-secrets.
De todos los valores que retorna la funciÃ³n, la llave vendrÃ­a a ser la correspondiente al atributo base64.

Generar el servicio de cifrado y descifrado.


Â°Â°Â°Â°Â°Â°Â°Â°Â° CryptoUtil Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°

Se convierte la clase en un componenete de spring boot.

*Donde se crean los atributos de clase*
 private var algorithm: String = "AES/CBC/PKCS5Padding"
 private var keyAlgorithm: String = "AES"

 @Value("\${secretKey}")
 private var secretKey: String = ""


// Decodifica Base64 si es posible, sino usa el string como estÃ¡
    private fun decodeBase64OrString(input: String): ByteArray {
        return try {
            // Intenta decodificar como Base64
            Base64.getDecoder().decode(input)
        } catch (e: Exception) {
            print(e.message)
            // Si falla, usa el string como bytes UTF-8
            input.toByteArray(Charsets.UTF_8)
        }
    }

// Cache para los bytes decodificados
    private val secretKeyBytes: ByteArray by lazy {
        decodeBase64OrString(secretKey)
    }

    fun cifrar(texto: String): String {
        try {
            // Validar que las llaves estÃ©n configuradas
            validarConfiguracion()

            // Crear la clave secreta desde bytes decodificados
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // ğŸ²GENERAR IV ALEATORIO (nuevo por cada cifrado)
            val ivAleatorio = ByteArray(16)
            SecureRandom().nextBytes(ivAleatorio)
            val ivParameterSpec = IvParameterSpec(ivAleatorio)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)

            // Cifrar el texto
            val textoCifrado = cipher.doFinal(texto.toByteArray(Charsets.UTF_8))

            // Devolver: IV_aleatorio + texto_cifrado (ambos en Base64)
            return Base64.getEncoder().encodeToString(ivAleatorio) + ":" +
                    Base64.getEncoder().encodeToString(textoCifrado)

        } catch (e: Exception) {
            throw Exception("Error al cifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para cifrar.

private fun validarConfiguracion() {
        if (secretKey.isBlank()) {
            throw IllegalStateException("La clave secreta no estÃ¡ configurada")
        }
    } -> Funcion para validar que exista la llave para cifrar y descrifrar.

fun descifrar(textoCifradoCompleto: String): String {
        try {
            // Validar que las llaves estÃ©n configuradas
            validarConfiguracion()

            // SEPARAR IV y texto cifrado (formato: "IV_base64:texto_base64")
            val partes = textoCifradoCompleto.split(":")
            if (partes.size != 2) {
                throw IllegalArgumentException("Formato invÃ¡lido. Debe ser: IV_base64:textoCifrado_base64")
            }

            val ivDecodificado = Base64.getDecoder().decode(partes[0])
            val textoCifradoDecodificado = Base64.getDecoder().decode(partes[1])

            // Crear la clave secreta
            val secretKey = SecretKeySpec(
                secretKeyBytes,
                keyAlgorithm
            )

            // Crear el vector de inicializaciÃ³n desde el IV recibido
            val ivParameterSpec = IvParameterSpec(ivDecodificado)

            // Inicializar el cifrador
            val cipher = Cipher.getInstance(algorithm)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec)

            // Descifrar el texto
            val textoDescifrado = cipher.doFinal(textoCifradoDecodificado)

            return String(textoDescifrado, Charsets.UTF_8)

        } catch (e: Exception) {
            throw Exception("Error al descifrar el texto: ${e.message}", e)
        }
    } -> Algoritmo para descifrar.

En el mismo controller, crear endpoints que llamen a la funciÃ³nes para cifrar y descifrar.



CREAR CLASE PARA INYECTAR VALORES 

@Configuration
@ConfigurationProperties(prefix = "clavePrincipal")
class CryptoConfig {
    var nombreAtributo1: String = ""
    var nombreAtributo2: String = ""
    var nombreAtributoN: String = ""
} -> Para crear una clase que contiene puros atributos, los cuales almacenaran valores de un
	application-personalizado.
	- @ConfigurationProperties(prefix = "clavePrincipal") -> Busca en el application default y despues 		busca en el application activo y al final busca en otros application extra activos las 
		claves que empiencen con el nombre clavePrincipal. 
		Se debe considerar que los valores se pueden sobreescribir, de tal modo que el ultimo 			application en escribir el valor para una clave, se tomara ese valor. **

*En un application*
clavePrincipal:
    clave1: valor1
    clave2: valor2
    claveN: valorN 

