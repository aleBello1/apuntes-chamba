/////////////////////////////////////REDIS CON SPRING BOOT/////////////////////////////////////

Configurar el proyecto -----------------------------

*En application.properties*

spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.password= 
spring.data.redis.timeout=time_ms -> Configuraciones necesarias para conectarse con redis.
	Redis por defecto escucha en el puerto: 6379. ****
	- spring.data.redis.host=localhost -> Para establecer la conexión con redis cuando 
		redis esta en la maquina local.
		Evidentemnte si redis estuviera en una mv se pondría la ip de esa mv. **
	- spring.data.redis.database=numero -> Para especificar el numero de la db a la que se 
		desea conectar.
		Por defecto se conectara a la db numero 0.
		Redis no maneja bases de datos por su nombre como MySQL, solo le asigna números
		a sus db's, cuando no se especifica el numero de la db a la que se desea 			conectar, se conecta a la db No. 0. Por defecto solo vienen 16 db's.
	- spring.data.redis.timeout=time_ms -> Es el tiempo máximo que Spring esperará una 
		respuesta de Redis.
		Si Redis no responde en ese tiempo → se lanza excepción.
		Esto también se usa para que cuando se caiga redis, no retrase las demás 
		operaciones pe consultar con la db de MySQL.
		Si Redis se cae y no configuras timeout los request pueden quedarse esperando 
		hasta ~60s.

logging.level.org.springframework.data.redis=DEBUG
logging.level.org.springframework.data.redis.core=DEBUG
logging.level.org.springframework.data.redis.connection=DEBUG -> Para ver logs de las operaciones
	hechas con redis.
	No son tan detalladas.


Patrón circuit breaker -----------------------------------------------

Es un patrón que:
Detecta que las llamadas a Redis están fallando.
Deja de intentar llamadas inútiles.
Se recupera cuando Redis vuelve.

Se usa cuando se depende de un sistema externo que puede fallar o volverse lento. *****
Para el caso de redis, el punto es poder manejar el caso en el que redis no este funcionado y podamos usar la db (MySQL, postresql, etc) en su lugar.

Si no se implementa, las request serán lentas porque siempre se intentara llamar a Redis y como
este podría tardar en responder entonces habrá timeouts largos (si se configura el timeout aun
así será muy lento la request).

Estados del circuit breaker:
- closed: Significa que todo funciona correctamente (redis funcionando).
- open: Significa que hay errores (redis esta fallando) y en este caso se deja de llamar a redis.
- half-open: prueba de recuperación. 

Resilience4j: Es una librería de resiliencia para Java/Kotlin. Se le llama resiliente porque 
resiste fallos externos sin caerse. Implementa patrones de diseño para manejar fallos externos 
de forma inteligente.
Proporciona: Circuit Breaker, Retry, Rate Limiter, Bulkhead, Time limiter.
Resuelve problemas reales de producción: servicios lentos, dependencias caídas, cascadas de fallos, saturación de threads.

Para aplicaciones con redis remoto se recomienda:

mínimo aceptable:
timeout corto
try/catch

Producción seria: 
timeout
Circuit Breaker + fallback
métricas + monitoreo (De este modo con aplicaciones de monitoreo sabremos el estado del circuito)


°°°°°°°° Configurar el circuit breaker °°°°°°

<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
</dependency> -> Dependencia para la resilience4J.
	Usado para spring boot v3.

resilience4j:
  circuitbreaker:
    instances:
      redisRemoteCB:
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3 -> Configuración de resilience4J para el 
		circuit breaker.
		- instances:
      			nombreInstancia: -> Crea una instancia de configuración.
				Este nombre debe coincidir con el name de la anotación circuit
				breaker. 
				Si tuviéramos dos redis: uno local y otro remoto, se debería 
				crear una instancia de configuración para cada redis.
		- slidingWindowSize: n -> Analiza n llamadas.
			Por defecto es una ventana basada en número de llamadas.
			Pero puede configurarse como ventana basada en tiempo.
		- failureRateThreshold: m -> si el m% de las llamadas fallan → abre circuito.
			El valor m es un numero entre 1 y 100.
		- waitDurationInOpenState: ps -> Configura Cuánto tiempo el circuito permanece 
			ABIERTO antes de intentar probar otra vez.
			Cuando el circuito esta abierto NO se intentan llamadas a Redis, todo
			se va directo al fallback.
			Después de este tiempo pasa a half open (prueba si redis volvió).
			Si este valor es muy bajo la app seguirá intentando conectarse a cada
			rato y será una saturación innecesaria y si lo pones muy alto puede que
			redis este de regreso pero te quedes mucho tiempo sin usarlo.
		- permittedNumberOfCallsInHalfOpenState: q -> Cuando el circuito pasa a 
			HALF-OPEN Solo se permiten q llamadas reales para probar si el sistema 
			ya se recuperó.
			Si el porcentaje de fallos en HALF-OPEN supera el threshold → vuelve a 
			OPEN.


°°°°°°°° Implementación del circuit breaker °°°°°°

Se crea la lase llamada RedisCacheRepository

||||||||||| En RedisCacheRepository ||||||||||||

@CircuitBreaker(name = "redisRemoteCB", fallbackMethod = "fallback")
fun <T> get(key: String, typeRef: TypeReference<T>): T? {
    val json = stringRedisTemplate.opsForValue().get(key)
        ?: return null

    return objectMapper.readValue(json, typeRef)
} -> Método que se usa para recuperar datos de redis si es que la clave existe.
	Si el método falla (por ejemplo porque no hay conexión con redis porque esta caído
	o si simplmenete se supera el timeout), se lanzara una excepción y ejecutara el método
	que se asigne al parámetro: 'fallbackMethod'.
	- fallbackMethod = "fallback" -> El método fallback debe cumplir reglas estrictas: Debe 		estar en la misma clase, Debe tener los mismos parámetros que el método que se 
		le pone la anotación CircuitBreaker y Debe agregar un parámetro extra al final
		de tipo Throwable.
		Cuando el circuito este abierto, el método con la anotación CircuitBreaker ni 			siquiera se ejecuta e inmediatamente se ejecuta su fallback.
	- name = "redisRemoteCB" -> Identifica una instancia específica del Circuit Breaker (de 
		los que se configuraron en el application en la opción instances: 				nombreInstancia).
		La conecta con una configuración concreta.
		Mantiene su propio estado independiente.

import com.fasterxml.jackson.core.type.TypeReference // Tiene que venir de Jackson.

fun <T> fallback(
    key: String,
    typeRef: TypeReference<T>,
    ex: Throwable
): T? {
    println("No se encontro esta request en redis: ${ex.message}")
    return null
} -> Método que se ejecuta si el método get falla.
	Si por alguna razón dentro de este método se pone un código que pueda lanzar una 
	excepción, esa ya no lo intercepta el circuit breaker y esa excepción si se propaga hacia
	arriba.

@CircuitBreaker(name = "redisRemoteCB", fallbackMethod = "fallbackSet")
fun set(key: String, value: Any, ttlHours: Long) {
    val json = objectMapper.writeValueAsString(value)
    stringRedisTemplate.opsForValue()
        .set(key, json, ttlHours, TimeUnit.HOURS)
} -> Método que se usa para insertar nuevos datos a redis con determinada clave.

fun fallbackSet(key: String, value: Any, ttlHours: Long, ex: Throwable) {
    println("No se pudo guardar esta request en redis: ${ex.message}")
} ->  Método que se ejecuta si el método set falla.

||||||||||| En NombreEntidadXCacheService ||||||||||||

Aquí se hace una combinación de los métodos que se definieron previamente con los métodos 
service que originalmente hacen la consulta hacia la db.

fun getNombreRecurso(): List<tipoDatoX> {

    val key = "nombreClave"

    val cached = redisCacheRepository.get(
        key,
        object : TypeReference<List<tipoDatoX>>() {}
    )

    if (cached != null) return cached

    val fromDb = nombreEntidadService.getNombreRecursoFromDb()

    redisCacheRepository.set(key, fromDb, tiempo)

    return fromDb
} -> Método para aplicar Cache Aside (Lazy Loading).
	Busca cierto recurso en redis si existe lo retornar pero si no lo busca en la db, lo 
	guarda en redis le aplica un ttl y lo retorna.
	Estos métodos a serian los que se mandarían a llamar en los controllers.


°°°°°°°° Implementación de monitoreo + alerta (en local) °°°°°°

Los que se implementa funciona para Ver cuánto tiempo el Circuit Breaker estuvo OPEN, Ver histórico de estados y Crear alertas si dura demasiado tiempo abierto.

Micrometer es una librería de métricas para JVM. Es la capa intermedia entre tu aplicación y el sistema de monitoreo.
Se encarga de Micrometer de Crear métricas (counter, gauge, timer), Las registra y Las exporta 
al sistema que tú elijas.
Desde Spring Boot 2, Micrometer viene integrado automáticamente.

Prometheus es un sistema de monitoreo basado en scraping.
Encargado de:
- Hace requests HTTP a tu app
- Lee métricas en formato especial
- Las guarda en una base de datos de series temporales (Prometheus tiene su propia base de datos de series temporales (TSDB), No vuelve lenta tu app, sin embargo tener una cardinalidad alta
puede ser peligroso porque puede matar al servidor de prometheus).
- Permite hacer queries y alertas
Prometheus NO recibe métricas.
Él las consulta periódicamente.

Grafana es una herramienta de visualización de métricas. NO guarda métricas y no recoleta 
métricas.
Encargado de:
- conecta a una fuente de datos (ej: Prometheus)
- Hace consultas
- Construye dashboards
- Muestra gráficas
- Permite configurar alertas **

Spring Boot usa:
Micrometer → para generar métricas.
Spring Boot Actuator → para exponerlas por HTTP.
Prometheus → para recolectarlas.
Grafana permite visualizarlas.


||||||||||| Configuración de dependencias ||||||||||||

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency> -> Agregar spring actuator.

<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency> -> Micrometer es multi-registry.
	Puede exportar métricas a: Prometheus, Datadog, New Relic, CloudWatch, etc. Pero 
	ncesita un “adaptador” para cada uno.
	Esta dependencia es el adaptador que Traduce las métricas de Micrometer Al formato que
	entiende Prometheus Y habilita /actuator/prometheus. 

management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus > Configurar spring actuator para exponer los enpoints
		relacionados con health, métricas y prometheus.

management:
  endpoint:
    prometheus:
      enabled: true -> Esto habilita específicamente el endpoint Prometheus.
	Estas configuraciones al estar dentro de la configuración management pueden y deben de ir
	juntas, es decir, la configuración 'endpoints' y 'endpoint' deben esta dentro de 
	managemnt.


||||||||||| Levantar prometheus ||||||||||||

En la raíz del proyecto se crea el archivo de configuración de prometheus llamado prometheus.yml.
 
global: -> Para hacer configuraciones globales de prometheus.
	Configuraciones para esta opción:
  	- scrape_interval: ns -> Cada n segundos Prometheus hará una petición HTTP a tu 
		aplicación para leer métricas.

scrape_configs: -> Lista de cosas que Prometheus debe monitorear.
	Se coloca una lista de Jobs, cada elemento nuevo empieza por el carácter '-'.
  	- - job_name: "nombreJob" -> Asigna que monitoreo determinado job.
		Un job puede ser uan app o una db.
	- metrics_path: "/actuator/prometheus" -> Le dice a Prometheus la URL donde debe leer 
		la métrica para este job.
	- static_configs:
		- - targets: ["host.docker.internal:puertoApp"] -> Indicarle a que servidor 
			conectarse, es decir, indicarla donde esta la app que debe consumir para
			recolectar las métricas.
			Se hace la suposición que la app esta corriendo en local y proteus 
			dentro de un contenedor, por eso se usa el 'host.docker.internal'.

Hacer que promethus consuma las métricas: 

docker network create red -> Se crea una red para que compartan prometheus y grafana.

*En la terminal de power shell*
docker run -d `
  --name prometheus `
  -p 9090:9090 `
  -v ${PWD}\prometheus.yml:/etc/prometheus/prometheus.yml `
  --network red `
  prom/prometheus -> Crear y ejecutar un contenedor con base a la imagen prom/prometheus.
	Prometheus corre en el puerto 9090 dentro del contenedor.
	Si se ejeucta en la terminal de git bash el ${PWD} se convierte en algo como:
	C:/Program Files/Git/… y Docker no lo interpreta como se espera por eso se ocupa 
	forzosamente la terminal de power shel.
	- -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml -> Es un volumen al cual se le
		dice Usa MI prometheus.yml personalizado En lugar del default del contenedor.

http://localhost:9090/targets -> En esta ruta prometheus enlista todas las rutas que esta 
	scrapenado/consumiendo, si está up ó down y cada cuanto las consulta.

http://localhost:9090/query -> Muestra que métricas tenemos disponibles con base a los endpoints
	que esta consumiendo prometheus.


||||||||||| Levantar y configurar grafana ||||||||||||

docker run -d --name grafana -p 3000:3000 --network red -v grafana_data:/var/lib/grafana 	grafana/grafana -> Crear y ejecutar un contenedor con base a la imagen grafana/grafana.
	- /var/lib/grafana -> Los dashboards, usuarios y configuraciones se guardan en esta 
		ruta.

docker run -d \
  --name grafana \
  -p 3000:3000 \
  --network red \
  -e GF_SMTP_ENABLED=true \
  -e GF_SMTP_HOST=smtp.gmail.com:587 \
  -e GF_SMTP_USER=correo_personal_empresa \
  -e GF_SMTP_PASSWORD=mi_contraseña \
  -e GF_SMTP_FROM_ADDRESS=correo_personal_empresa \
  -e GF_SMTP_FROM_NAME="Grafana Alerts" \
  -e GF_SMTP_SKIP_VERIFY=false \
  -v grafana_data:/var/lib/grafana \
  grafana/grafana -> Manera en el que se debe crear el contendor si es que se usara para pruebas
	locales el correo personal de Gmail.
	- GF_SMTP_PASSWORD=mi_contraseña -> Es la contraseña que nos da Gmail especial para 
		aplicaciones.
	- GF_SMTP_HOST=smtp.gmail.com:587 -> Este es el especifico valor para Gmail, al usar
		otro aplicación de correo este valor podría variar.
	- GF_SMTP_FROM_NAME="Grafana Alerts" -> Define el nombre visible del remitente del 
		correo.
	- -e GF_SMTP_FROM_ADDRESS=alerts@empresa.com -> Define el nombre visible del correo 			remitente del correo.
		De tal modo que esta configuración en combinación con la anterior, al usuario
		le llegara el correo asi: Grafana Alerts <alerts@empresa.com>.

Al ingresar el usuario y contraseña será admin, posteriormente nos pedirá cambiar la contraseña.

Conectar grafana con prometheus: *Ingresar a prometheus y grafana antes para asegurarse que
	funciona bien* -> menú izq. connections -> data sources -> add data source -> prometheus
	-> Ingresar en la url el valor http://prometheus:9090, se usa el nombre del contenedor
	que alamcena a prometheus y su puerto -> save and test.

Para visualizar el tiempo en el que promethues ha estado consumiendo actuator: Apartado izq. 
	explore -> seleccionar prometheus -> en metric buscar y seleccionar up -> run query.
	Es una métrica interna de Prometheus.
	- 1 = el target está activo
	- 0 = no puede conectarse

*La demás teoria de grafana esta en su propio txt*