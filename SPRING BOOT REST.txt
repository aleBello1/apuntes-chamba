@Column(length = n)
private String nombreAtributo; -> Por defecto, JPA/Hibernate asigna VARCHAR(255) a cualquier String 
	si no se le indica lo contrario, pero si desea que el campo siga siendo de tipo varchar y pueda 	almacenar mas caracteres entonces se debe especificar el tamanio del varchar en esta anotación.


//////////////////////////////////////OTROS///////////////////////////////

SPRING BOOT ACTUATOR

ulr's de spring actuator:
	- /actuator/health → Define el estado de la app (si está UP, DOWN, etc.).
	- /actuator/metrics → Se ven métricas (CPU, memoria, etc.)
	- /actuator/env → variables de entorno
	- /actuator/beans → lista de beans cargados.
	- /actuator/mappings → todos los endpoints registrados en Spring.
	- /actuator/info → sirve para exponer información “general” de la aplicación.
		Solo devuelve información que fue configurada en algún application.
	- y muchos más.

*En application.properties*

management.endpoints.web.exposure.include=valor -> Define que endpoints de spring actuator se pueden 	consumir.
	Por defecto, Spring Boot solo expone health e info. Eso quiere decir que si no configuras nada, 
	solo esos dos estarán accesibles.
	No es recomendable en producción porque puede mostrar información sensible. ****
	- * -> Para que se puedan consumir todos.

management.endpoint.health.show-details=always -> Sirve para que el endpoint de health de mas detalles
	pe si La base de datos está disponible, si la app Puede conectarse al broker de mensajería (Kafka, 
	RabbitMQ, etc.), si se pudo conectar con el servidor externo donde se traen otras configuraciones
	(la opción spring.config.import=valor) 
	Configuración opcional.

Definir información para /actuator/info ------------------------

*En application.properties*

info.app.name=MiAplicacion
info.app.version=1.2.3
info.app.description=Servicio de catálogo de autos

info.build.time=2025-08-26T10:00:00Z
info.build.artifact=mi-aplicacion
info.build.group=com.miempresa


CONFIGURACIONES EN LOS APPLICATION

spring.main.allow-circular-references=true -> Para permitir referencias circulares entre beans.
	Una referencia circular sucede cuando dos o más beans dependen entre sí directamente o de 
	manera indirecta. Pe supongamos que la clase ServiceA inyecta a ServiceB y la clase ServiceB inyecta 	a ServiceA, esto provoca una referencia circular. Esto crea un ciclo que, por defecto, en Spring 	Boot 2.6 en adelante se considera un error.
	A partir de spring boot v2.6, el valor por defecto es false.
	Si se tienen referencias circulares y no se activa esta opción, al correr la aplicación esta 
	fallara.
	Para eliminar la dependencia circular, se introducie un tercer bean que rompa el ciclo. ****
 

Configuraciones para pool de conexiones -----------------------

Pool de conexiones: son varias conexiones listas para usar, en lugar de abrir y cerrar una conexión cada
vez.
Sin pool: cada vez que necesitas acceder a la base de datos, abres una conexión → haces tu consulta → cierras la conexión. Esto es lento porque abrir y cerrar conexiones constantemente consume tiempo y recursos.
Con pool: la aplicación toma una conexión que ya estaba abierta → hace la consulta → devuelve la conexión al pool. Así, la misma conexión puede reutilizarse muchas veces, y tu app va mucho más rápido y consume menos recursos.

spring.datasource.validation-query=SELECT 1 -> Consulta que se usa para verificar si la conexión sigue 
	viva. Por sí sola, no valida automáticamente; solo le dice al pool qué consulta ejecutar cuando 
	haga la validación.
	Esto solo es necesario en algunos pools (como Tomcat JDBC o DBCP), mientras que HikariCP lo 
	hace automáticamente con su “ping” interno.
	Si tu DB se reinicia con frecuencia o hay firewalls que cierran conexiones, validation-query
	ayuda a evitar errores como Connection reset o CommunicationsException. ****

spring.datasource.test-while-idle=true -> Indica cuándo ejecutar la consulta de validación (la de 
	validation-query o alguna equivalente), en este caso, mientras la conexión está inactiva en el 
	pool.
	Para que funcione correctamente, necesita que también exista validationQuery o que el pool 
	tenga otro método de validación.

spring.datasource.hikari.maximum-pool-size=n -> Controla el tamaño máximo del pool de conexiones.
	el valor por defecto es: 10.
	Si lo pones muy alto, puedes sobrecargar la base de datos.


COMO SE GUARDAN LOS LOGS Y QUE SE GUARDA

Se tiene un try-catch-finally, donde el try comienza cuando se comeinza a interactuar varias veces con un servicio externo.
	- Contenido del try: Inmediatamente después de la llamada a un servicio externo se coloca un if 
		que valida si el servicio fallo y si este falla se lanza una excepción o exception 			personalizada con el error que manda el servicio externo, si un servicio nuestro falla se 		puede lanzar una exception o excepción personalizada con un mensaje que describa ese error.
	- Contenido de los catch: Habra 2 o mas catch: uno para el catch mas genérico (Exception), otros 		para las exceptiones personalizadas (si las hay) y otros para exceptiones mas especificas 		(solo si las hay).
		En cualquier catch habrá cualquiera de las 3 siguientes instrucciones o las 3: un print
		para imprimir en la consola y guiarnos sobre mas o menos que fue lo paso, un 				e.printStackTrace() para que en la consola apareza mensajes en rojo y llenar el atributo 		error que esta en el objeto que se envia al fron.
	- Contenido del finally: se coloca un try-catch.
		- Contenido del try: se instancia un objeto de logs y se llena con los siguientes datos:
			el objeto request (que recibimos del fron), el objeto request (que se preparo para
			el servicio externo), el objeto response (que enviamos al fron), el bojeto response
			(que nos respondio el servicio externo), la fecha y hora, el atributo error que
			viene en el objeto respuesta que enviamos al forn, numero de proceso (si aplica),
			user_id (si aplica, para saber qué usuario causó el evento). Se guarda ese objeto
			en su respectiva tabla.
		- Contenido del catch: un print para imprimir 'error al guardar en los logs en el proceso
			equis', un e.printStackTrace() para que en la consola apareza mensajes en rojo y 
			llenar el atributo error que esta en el objeto que se envia al fron con el mismo 
			mensaje que en el print.

Ejemplo para el try:

xmlResCot = helper.connect(xml)
val jsonObj = toJSONObject(xmlResCot)
//La aseguradora dentro del XML, en el parametro (etiqueta) return regresa una cadena que es un json
// entonces se debe verificar si regreso este json
val responseString = jsonObj.getJSONObject("soapenv:Envelope").getJSONObject("soapenv:Body")
    .getJSONObject("ns2:cotizarPolizaResponse").getString("return")
//si no es un json de respuesta
if (responseString[0] != '{') {
    throw Exception(responseString)
}

Ejemplo para los catch:

} catch (e: Exception) {
    println("ERROR AL REALIZAR COTIZACION")
    e.printStackTrace()
    response.codigoError = quoteCommon.customErrorMessage(e, request, idTipoVehiculo, businessType)
} catch (e: CustomException) {
    println("ERROR AL REALIZAR COTIZACION")
    e.printStackTrace()
    response.codigoError = "${e.message}"
} 




///////////////////////////////////////////AVANZADO//////

JOBS

logging.level.org.springframework.scheduling=DEBUG -> Para que cuando la aplicación arranque, spring 
	boot mustre qué schedulers se registraron.

scheduler.cron=segundo minuto hora díaDelMes mes díaDeLaSemana año(opcional) -> Para configurar un 
	scheduler (programador de tareas).
	Indica cuándo debe ejecutarse una tarea programada.
	Ejemplo si 0 0/30 12-16 8/10 * ?, entonces:
		0 → segundo: en el segundo 0.
		0/30 → minuto: cada 30 minutos, empezando en el minuto 0 (0 y 30).
		12-16 → hora: de 12 PM a 4 PM (inclusive).
		8/10 → día del mes: empieza en el día 8 y luego cada 10 días (8, 18, 28…).
		* → mes: todos los meses.
		? → día de la semana: no se especifica (evita conflicto con el día del mes).



