


HABILITAR EL CORS

Un cliente (pe js vanilla, react, angular, etc) y Spring Boot corren en puertos 
distintos. Esto hace necesario habilitar CORS (Cross-Origin Resource Sharing).

En el pacakge principal crear el paquete config/ y dentro la clase de configuracion, la cual se 
encargara de habilitar el cors.

En WebConfig.java  --------------------------------------

@Configuration
public class WebConfig {
    @Bean
    WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("http://localhost:numPuertoCliente")
                        .allowedMethods("GET", "POST", "PUT", "DELETE")
                        .allowCredentials(true);
            }
        };
    }
} -> Habilita el cors.
	Para que la API permitá llamadas desde cualquier origen, con cualquier método, con cualquier 	header, y enviando credenciales.
	- .addMapping("/**") -> Aplicar la configuración a todas las rutas de tu API.
	- .allowedOrigins("*") -> Permite cualquier origen (cualquier dominio) lance peticiones
		a la api.
		En produccion, lo ideal es usar .allowedOrigins("http://localhost:numPuertoCliente") 		para especificar el dominio del fron que consumirá nuestra api. **
		No se permite tener .allowedOrigins("*") y .allowCredentials(true) al mismo tiempo. ***
	- .allowedOriginPatterns("*") -> Permite cualquier origen (cualquier dominio) lance peticiones
		a la api.
		La diferencia con allowedOrigins("*") es que esta configuración si permite
		usar allowCredentials(true). ***
	- .allowedMethods("*") -> Permite todos los métodos http.
	- .allowedHeaders("*") -> Permite que el navegador envíe cualquier header: Authorization,
		Content-Type, X-Custom, Etc.
	- .allowCredentials(true) -> Permite que el navegador envíe: Cookies, Authorization Bearer, 		Tokens, Headers con credenciales, Sessions.




/////AVANZADO////

METODOS DE FABRICA

Un método de fábrica pertenece a la clase, no al objeto.

public class NombreClaseDto {

    private tipoDato atributo1;
    private tipoDato atributo2;
    private tipoDato atributoN;

    public static NombreClaseDto from(NombreClaseEntidad objetoEntidad) {
        NombreClaseDto dto = new NombreClaseDto();
        dto.setAtributo1(objetoEntidad.getAtributo1());
        dto.setAtrito2(objetoEntidad.getAtributo2());
        dto.setAtritoM(objetoEntidad.getAtributoM());
        return dto;
    }
} -> El método statico se encarga de convertir un objeto entidad a objeto DTO.
	En este escenario, la clase dto tiene menos atributos que la clase entity y en escencia
	todos los atributos que tiene el dto los tiene la entity. ***

NombreClaseEntity objetoEntityDb = ... ; // Se obtiene al objeto entity de la db.
NombreClaseDto objetoDto = NombreClaseDto.from(objetoEntityDb); -> Para convertir un solo objeto
	entidad a objeto DTO.

List<NombreClaseDto> arrayDtos =
        objetosEntityDb.stream()
               .map(NombreClaseDto::from)
               .toList(); -> Para convertir una lista de objetos entidad a una lista de objetos DTO.





