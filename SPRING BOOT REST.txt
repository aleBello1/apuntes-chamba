@Lob
private String nombreAtributo; -> Por defecto, JPA/Hibernate asigna VARCHAR(255) a cualquier String 
	si no se le indica lo contrario, pero si dsea que el campo pueda almacenar mas caracteres
	entonces se debe cambiar a otro tipo de dato en el campo pe longText, TEXT, mediumText. En JPA la
	anotación @Lob (Large Object) le dice a Hibernate que el campo debe almacenarse como CLOB 
	(Character Large Object) en SQL, lo que en MySQL se traduce a LONGTEXT.
	- @Lob
	  @Column(columnDefinition = "TEXT")
	  private String nombreAtributo; -> Para que en MySQL el campo se guarde como text y no 
		como longText.

@Transactional -> No es compatible con corrutinas asincrónicas, entonces si un método service contiene
	operaciones de corrutinas o hilo no se debe usar. *********
	Si se tiene un servicio 1 que consume a un servicio 2, el servicio 1 en su capa de services, 
	sus metodos pueden omitir la anotacion transactional. *********
	Cuando se usa métodos estándar de Spring Data JPA (como pe: save(), delete(), etc.), Spring ya los 	envuelve en una transacción automáticamente. Mientras que, operaciones personalizadas de 
	INSERT, UPDATE ó DELETE hechas con @Modifying + @Query se deben envolver dentro de uan transaction
	(en la clase repository) pero si el método de servicio usa muchas de estas operaciones 	personalizadas se debe anotar también con @transactional para agruparlas en una sola 
	transacción.


Crear una ruta de primer nivel, ruta raiz ó ruta base -------------


°°°°°° ruta base con path variable °°°°°°°


Se define un path variable en la ruta base.

@RestController
@RequestMapping("/api/vehiculos-{nombreParametroY}")
public class NombreEntidadController {}

Pero es hasta cierto método del controlador que se capture ese valor.

@GetMapping("/nombreRutaX/{nombreParametroY}")
public ResponseEntity<?> nombreMetodoX(@PathVariable tipoDato nombreParametroY) {
    // N instrucciones
} 



MEJORAS

Aplicar la inyección de dependencias correctamente.
Quitar los transactional y modifyin ineccesarios de la capa repository.
Remover los imports que no se usen.
Agregar los transactional y transactional read only en el service cuando se necesite (cuando se acceda
a la db y no a un servicio externo (api rest o api soap)).
Corregir el nombre de clases, enums, etc.
Refactorizar variables, lógica, etc.


DTO

@JsonAlias({"nombre1", "nombre2", "nombreN"})
private tipoDato nombreAtributoX; -> Para indicar que una propiedad o atributo de un objeto json, debe 	deserializarse pero este nombre de atributo pude tener múltiples nombres.
	Usado cuando se esta recibiendo datos JSON de fuentes externas (como un Web Service), y a veces los 	campos pueden venir con diferentes nombres pero debe interpretarse com un mismo atributo.






PERFILES

Para elegir cual perfil de spring boot utilizar cuando se corra la aplicación hay varias formas.


Configurando el application.properties -----------------------------------

spring.profiles.active=nombrePerfil -> Como Spring siempre carga primero application.properties como 	configuración base o común porque es el perfil default, es en este archivo donde se coloca la 	instrucción de cual perfil seleccionar.
	Se puede tener unas configuraciones en application.properties y en 
	application-nombePerfilSelecionado.properties, si alguna de las configuraciones del 
	application-nombePerfilSelecionado.properties son las mismas que las de application.properties, se 	sobreescriben. Esto permite Tener propiedades comunes en application.properties y solo diferencias 	específicas en application-{perfil}.properties.
	 

Cuando se crea el -jar -----------------------------------

java -jar mi-aplicacion.jar --spring.profiles.active=nombrePefil -> Cargara determinado 	application.properties, clases y beanes.


CREACION DE PROYECTOS (CON VSC Y SBv3)

	Dependencias:
		Creacion de web flux:
		spring reactive web -> 
		mongodb-reactive -> 
		

DTO

Hay de dos tipos: de entrada y salida.
Entrada: 
	- Cuando vienen de un cliente (un fron). 
	Ejemplo: cuando no requerimos todos los datos pe solo necesitamos username y contraseña para logear
	un usuario.
	- Cuando consumimos un web service, es decir, un servicio externo como pe una api rest, api soap,
		etc.

Salida: Son como vistas personalizadas (como en sql), los cuales se envían al cliente (fron)
	Ejemplo: una tabla user tiene los campos nombre, edad apellido y password, al cliente no le
	enviaremos el password, asi que solo todo lo demás.


JOBS

@EnableScheduling
*Sobre la clase principal* -> Activa la capacidad de programar tareas automáticas (tareas recurrentes) en 
	tu aplicación. Es decir, te permite ejecutar métodos en intervalos específicos (como cada minuto, 
	cada hora, a una hora fija, etc.) sin necesidad de intervención manual.
	Habilita el uso de las anotaciones: @Scheduled y @Schedules.


SAVE VS SAVEALL VS INSERCION PERSONALIZADA

La velocidad de inserción de datos depende del volumen de registros.

Usar save() para insertar muchos registros: es más rápido cuando insertas pocos registros (ej. 1 a 10).
Si insertas miles de registros, genera múltiples consultas SQL individuales (lento).

Usar saveAll() para insertar muchos registros: es más rápido cuándo cuando insertas cientos o miles de registros. Solo será rápido si activas las configuraciones de batch inserts en Hibernate, si no se activan saveAll se comporta como si se llamara a save de uno en uno.

Usar Inserción Personalizada (JPQL o SQL nativo) para insertar muchos registros: es más rápido cuando insertas grandes volúmenes de datos (miles/millones).




