/////////////////////////////////////REDIS CON SPRING BOOT/////////////////////////////////////

Agregar dependencia --------------------------------

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency> -> Dependencia para que spring boot use redis.

Configurar el proeycto -----------------------------

*En application.properties*

spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.password=-> Configuraciones necesarias para conectarse con redis.
	Redis por defecto escucha en el puerto: 6379. ****
	- spring.data.redis.database=numero -> Para especificar el numero de la db a la que se 
		desea conectar.
		Por defecto se conectara a la db numero 0.
		Redis no maneja bases de datos por su nombre como MySQL, solo le asigna números
		a sus db's, cuando no se especifica el numero de la db a la que se desea conectar, 
		se conecta a la db No. 0. Por defecto solo vienen 16 db's.
	- spring.data.redis.timeout=time_ms -> 
		El timeout solo se suele usar cuando:
			Redis está en otra red.
			Hay problemas de latencia.

logging.level.org.springframework.data.redis=DEBUG
logging.level.org.springframework.data.redis.core=DEBUG
logging.level.org.springframework.data.redis.connection=DEBUG -> Para ver logs de las operaciones
	hechas con redis.
	No son tan detalladas.

Opcional: crear un redisTemplate personalizado -----------------------------

Dentro de config/ se crea la clase RedisConfig.

@Configuration
public class RedisConfig {}

@Bean
public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        return template;
} -> Para crear un RedisTemplate personalizado.
	Spring Boot ya trae un redisTemplate por defecto Pero solo sirve si: los keys son string y 
	los valores también son strings. es decir, si el valor de una clave es un json lo 
	obtendremos como string y después lo tendremos que pasar objeto manualmente si necesitamos
	manipular el contenido del json.
	Evidentmente, No será necesario crearlo si todos los valores son json y no se necesita 	manipular estos objetos

usar redisTemplate ------------------------------------------

*En una clase service*
@Autowired
private StringRedisTemplate stringRedisTemplate; -> Para inyectar redisTemplate.


°°°°°°° Operaciones para strings °°°°°°°°°

Usado comúnmente para guardar: tokens, flags, contadores y json guardado como string.

stringRedisTemplate.opsForValue().get(key) -> Devuelve el valor asociado a cierta clave.

stringRedisTemplate.opsForValue().set("nombreClave", "valorX"); -> Guarda el valor equis con 
	cierta clave.


°°°°°°° Operaciones para listas °°°°°°°°°

Usado comúnmente para guardar: colas simples, logs y tareas pendientes.

stringRedisTemplate.opsForList().rightPush("queue", "valor");  -> Agrega un elemento al final de 
	una lista.

stringRedisTemplate.opsForList().leftPop("queue"); -> Saca y devuelve el primer elemento.

Existen operaciones para: Sets, Sorted Set, Hashes (tipo “JSON plano”), Operaciones geoespaciales,
entre otros.


°°°°°°° Metodos generales °°°°°°°°°

stringRedisTemplate.hasKey("key") -> Pregunta si una clave existe.

stringRedisTemplate.delete("key") -> Elimina la clave.

stringRedisTemplate.expire("key", n, unidad) ->  Le pone tiempo de expiración a una clave.
	Unidad:
	- TimeUnit.SECONDS
	- TimeUnit.MINUTES

stringRedisTemplate.getExpire("key") -> Obtiene el TTL (time to live) de una clave.
	valores que retorna:
	- -1: La clave no tiene expiración (es permanente).
	- -2: La clave no existe.
	- >= 0: Tiempo restante (por defecto en segundos)

stringRedisTemplate.persist("key") -> Quita el TTL a una clave, la hace permanente.

stringRedisTemplate.rename("old", "new") -> Renombra una clave.

stringRedisTemplate.randomKey() -> Devuelve una clave aleatoria.


°°°°°°° Transacciones °°°°°°°°

stringRedisTemplate.multi() -> Inicia una transacción.

stringRedisTemplate.exec() -> Ejecuta la transacción.


°°°°°°° Otros metodos °°°°°°°°

stringRedisTemplate.executePipelined(...) -> Envía muchos comandos juntos para eficiencia.

stringRedisTemplate.execute(...) -> Permite ejecutar comandos “crudos” del cliente Redis.


°°°°°°° Manera leer un json array y convertirlo en una lista de objetos java °°°°°°°°

Esto se hace después de comprobar que existe la clave.

String json = stringRedisTemplate.opsForValue().get(idNegocio); -> Extraer el valor asociado
	a una clave.

if (json == null || json.isEmpty()) {
    return Collections.emptyList();
} -> Si el valor de la clave esta vacio retonrar una lista vacia.

List<nombreClaseX> brands = objectMapper.readValue(
    json,
    new TypeReference<List<nombreClaseX>>() {} 
); -> Convierte un array json a una lista de objetos java.







