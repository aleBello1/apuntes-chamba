@Column(length = n)
private String nombreAtributo; -> Por defecto, JPA/Hibernate asigna VARCHAR(255) a cualquier String 
	si no se le indica lo contrario, pero si desea que el campo siga siendo de tipo varchar y pueda 	almacenar mas caracteres entonces se debe especificar el tamanio del varchar en esta anotación.


//////////////////////////////////////OTROS///////////////////////////////

SPRING BOOT ACTUATOR

ulr's de spring actuator:
	- /actuator/health → Define el estado de la app (si está UP, DOWN, etc.).
	- /actuator/metrics → Se ven métricas (CPU, memoria, etc.)
	- /actuator/env → variables de entorno
	- /actuator/beans → lista de beans cargados.
	- /actuator/mappings → todos los endpoints registrados en Spring.
	- /actuator/info → sirve para exponer información “general” de la aplicación.
		Solo devuelve información que fue configurada en algún application.
	- y muchos más.

*En application.properties*

management.endpoints.web.exposure.include=valor -> Define que endpoints de spring actuator se pueden 	consumir.
	Por defecto, Spring Boot solo expone health e info. Eso quiere decir que si no configuras nada, 
	solo esos dos estarán accesibles.
	No es recomendable en producción porque puede mostrar información sensible. ****
	- * -> Para que se puedan consumir todos.

management.endpoint.health.show-details=always -> Sirve para que el endpoint de health de mas detalles
	pe si La base de datos está disponible, si la app Puede conectarse al broker de mensajería (Kafka, 
	RabbitMQ, etc.), si se pudo conectar con el servidor externo donde se traen otras configuraciones
	(la opción spring.config.import=valor) 
	Configuración opcional.

Definir información para /actuator/info ------------------------

*En application.properties*

info.app.name=MiAplicacion
info.app.version=1.2.3
info.app.description=Servicio de catálogo de autos

info.build.time=2025-08-26T10:00:00Z
info.build.artifact=mi-aplicacion
info.build.group=com.miempresa



CONFIGURACIONES EN LOS APPLICATION

spring.main.allow-circular-references=true -> Para permitir referencias circulares entre beans.
	Una referencia circular sucede cuando dos o más beans dependen entre sí directamente o de 
	manera indirecta. Pe supongamos que la clase ServiceA inyecta a ServiceB y la clase ServiceB inyecta 	a ServiceA, esto provoca una referencia circular. Esto crea un ciclo que, por defecto, en Spring 	Boot 2.6 en adelante se considera un error.
	A partir de spring boot v2.6, el valor por defecto es false.
	Si se tienen referencias circulares y no se activa esta opción, al correr la aplicación esta 
	fallara.
	Para eliminar la dependencia circular, se introducie un tercer bean que rompa el ciclo. ****
 

Configuraciones para pool de conexiones -----------------------

Pool de conexiones: son varias conexiones listas para usar, en lugar de abrir y cerrar una conexión cada
vez.
Sin pool: cada vez que necesitas acceder a la base de datos, abres una conexión → haces tu consulta → cierras la conexión. Esto es lento porque abrir y cerrar conexiones constantemente consume tiempo y recursos.
Con pool: la aplicación toma una conexión que ya estaba abierta → hace la consulta → devuelve la conexión al pool. Así, la misma conexión puede reutilizarse muchas veces, y tu app va mucho más rápido y consume menos recursos.

spring.datasource.validation-query=SELECT 1 -> Consulta que se usa para verificar si la conexión sigue 
	viva. Por sí sola, no valida automáticamente; solo le dice al pool qué consulta ejecutar cuando 
	haga la validación.
	Esto solo es necesario en algunos pools (como Tomcat JDBC o DBCP), mientras que HikariCP lo 
	hace automáticamente con su “ping” interno.
	Si tu DB se reinicia con frecuencia o hay firewalls que cierran conexiones, validation-query
	ayuda a evitar errores como Connection reset o CommunicationsException. ****

spring.datasource.test-while-idle=true -> Indica cuándo ejecutar la consulta de validación (la de 
	validation-query o alguna equivalente), en este caso, mientras la conexión está inactiva en el 
	pool.
	Para que funcione correctamente, necesita que también exista validationQuery o que el pool 
	tenga otro método de validación.

spring.datasource.hikari.maximum-pool-size=n -> Controla el tamaño máximo del pool de conexiones.
	el valor por defecto es: 10.
	Si lo pones muy alto, puedes sobrecargar la base de datos.


COMO SE GUARDAN LOS LOGS Y QUE SE GUARDA

Se tiene un try-catch-finally, donde el try comienza cuando se comeinza a interactuar varias veces con un servicio externo.
	- Contenido del try: Inmediatamente después de la llamada a un servicio externo se coloca un if 
		que valida si el servicio fallo y si este falla se lanza una excepción o exception 			personalizada con el error que manda el servicio externo, si un servicio nuestro falla se 		puede lanzar una exception o excepción personalizada con un mensaje que describa ese error.
	- Contenido de los catch: Habra 2 o mas catch: uno para el catch mas genérico (Exception), otros 		para las exceptiones personalizadas (si las hay) y otros para exceptiones mas especificas 		(solo si las hay).
		En cualquier catch habrá cualquiera de las 3 siguientes instrucciones o las 3: un print
		para imprimir en la consola y guiarnos sobre mas o menos que fue lo paso, un 				e.printStackTrace() para que en la consola apareza mensajes en rojo y llenar el atributo 		error que esta en el objeto que se envia al fron.
	- Contenido del finally: se coloca un try-catch.
		- Contenido del try: se instancia un objeto de logs y se llena con los siguientes datos:
			el objeto request (que recibimos del fron), el objeto request (que se preparo para
			el servicio externo), el objeto response (que enviamos al fron), el bojeto response
			(que nos respondio el servicio externo), la fecha y hora, el atributo error que
			viene en el objeto respuesta que enviamos al forn, numero de proceso (si aplica),
			user_id (si aplica, para saber qué usuario causó el evento). Se guarda ese objeto
			en su respectiva tabla.
		- Contenido del catch: un print para imprimir 'error al guardar en los logs en el proceso
			equis', un e.printStackTrace() para que en la consola apareza mensajes en rojo y 
			llenar el atributo error que esta en el objeto que se envia al fron con el mismo 
			mensaje que en el print.

Ejemplo para el try:

xmlResCot = helper.connect(xml)
val jsonObj = toJSONObject(xmlResCot)
//La aseguradora dentro del XML, en el parametro (etiqueta) return regresa una cadena que es un json
// entonces se debe verificar si regreso este json
val responseString = jsonObj.getJSONObject("soapenv:Envelope").getJSONObject("soapenv:Body")
    .getJSONObject("ns2:cotizarPolizaResponse").getString("return")
//si no es un json de respuesta
if (responseString[0] != '{') {
    throw Exception(responseString)
}

Ejemplo para los catch:

} catch (e: Exception) {
    println("ERROR AL REALIZAR COTIZACION")
    e.printStackTrace()
    response.codigoError = quoteCommon.customErrorMessage(e, request, idTipoVehiculo, businessType)
} catch (e: CustomException) {
    println("ERROR AL REALIZAR COTIZACION")
    e.printStackTrace()
    response.codigoError = "${e.message}"
} 



MANEJO DE COOKIES

Las cookies son pequeños archivos de texto que los sitios web almacenan en el navegador (Chrome, Firefox, etc.) cuando se visita una página.
Cada cookie guarda datos específicos y se envía de vuelta al servidor cada vez que se hace una petición.

Los principales usos son:
Mantener sesiones activas: cuando inicias sesión en un sitio (Facebook, Gmail, etc.), se guarda una cookie con tu ID de sesión, así no tienes que volver a meter tu usuario y contraseña en cada clic
Recordar preferencias: Guardan configuraciones como idioma, tema oscuro/claro, tamaño de letra, etc.
Publicidad y personalización: Usadas por Google Ads, Facebook Pixel, etc. para mostrarte anuncios según lo que buscaste o visitaste antes.

*Dentro de un metodo en el controlador*
public tipoDato nombreMetodo(@CookieValue(value = "NOMBRE_COOKIE", defaultValue = "valorDefecto") String cookieValue) {
    // contenido controlar
} -> Manera de atrapar a cierta cookie en el controlador.
	- @CookieValue(...) -> Para atrapar cookies. 
		- value = "NOMBRE_COOKIE" -> revisa si la petición trae una cookie con este nombre.
		- defaultValue = "valorDefecto" -> Si la cookie no existe, utiliza este valor por defecto.



CONFIGURACIONES PARA SUBIDA DE ARCHIVOS

spring.servlet.multipart.max-file-size=formato -> Establece el tamaño máximo permitido para un archivo 	individual que se puede subir en una solicitud.
	Formato: número + unidad (B, KB, MB, GB). ***
	Si un archivo excede el limite, lanza MaxUploadSizeExceededException.
	Valor por defecto: 1MB  

spring.servlet.multipart.max-request-size=formato -> Establece el tamaño máximo total de toda la solicitud
	multipart, incluyendo todos los archivos + campos de formulario + headers.
	Valor por defecto: 10MB 

file.upload-dir=./nombreCarpeta/ -> Crea una carpeta relativo al directorio desde donde ejecutas tu 
	aplicación Spring Boot.
	En esta carpeta se almacenaran los archivos que se suban a la app.
	Esta carpeta NO se crea automáticamente, se debe crear la carpeta manualmente o programáticamente.


///////////////////////////////////////////AVANZADO//////

JOBS

logging.level.org.springframework.scheduling=DEBUG -> Para que cuando la aplicación arranque, spring 
	boot mustre qué schedulers se registraron.

scheduler.cron=segundo minuto hora díaDelMes mes díaDeLaSemana año(opcional) -> Para configurar un 
	scheduler (programador de tareas).
	Indica cuándo debe ejecutarse una tarea programada.
	Ejemplo si 0 0/30 12-16 8/10 * ?, entonces:
		0 → segundo: en el segundo 0.
		0/30 → minuto: cada 30 minutos, empezando en el minuto 0 (0 y 30).
		12-16 → hora: de 12 PM a 4 PM (inclusive).
		8/10 → día del mes: empieza en el día 8 y luego cada 10 días (8, 18, 28…).
		* → mes: todos los meses.
		? → día de la semana: no se especifica (evita conflicto con el día del mes).

Crear el packege llamado Jobs, asignarle el nombre a la clase y anotarla como component de spring.


En Jobs/NombreJobJob.java ----------------------------------------

@Scheduled(...)
public void executeTask() {
    // contenido
} -> Crea una tarea.
	- @Scheduled(...) -> Todos los método se anotan con @Scheduled para especificar la frecuencia de 
		ejecución.
		Opciones de @Scheduled:
		- fixedRate = valorMiliSegundos -> Para que la tarea se ejecute cada cierta cantidad de 			tiempo después de que inica la ejecución de esta tarea.
			Cuando se arranca la aplicacion se ejecuta la tarea, despues sin esperar a que la
			tarea termine de ejecutarse, ya estamos esperando fixedRate milisegundos para 				ejecutarse de nuevo y asi sucesivamnete. ****
			Usado en Tareas que deben ejecutarse a intervalos regulares.
			si la tarea tarda más que el intervalo, podría solaparse la ejecución. ******
			Pe inicia la aplicación (segundo 0) -> se ejecuta la tarea (en el segundo 0) pero
			la tarea le toma 2 segundos -> si fixed vale 5 segundos, entonces la tarea se 
			ejecuta en el segundo 5 -> de nuevo se ejecutaría en el segundo 10.
		- fixedDelay = valorMiliSegundos -> Para que la tarea se ejecute cada cierta cantidad de 			tiempo después de que termina la ejecución de esta tarea.
			Cuando se arranca la aplicacion se ejecuta la tarea, despues del tiempo que le tome
			a la tarea ejecutarse, se espera fixedDelay milisegundos para ejecutarse de nuevo y 			asi sucesivamnete. ****
			Usado en Tareas que no deben solaparse. ***********
			Pe inicia la aplicación (segundo 0) -> se ejecuta la tarea (en el segundo 0) pero
			la tarea le toma 2 segundos -> si fixed vale 5 segundos, entonces la tarea se 
			ejecuta en el segundo 7 -> de nuevo se ejecutaría en el segundo 14 (2 sec que le 
			toma la método ejecutarse mas 5).
		- cron: Permite especificar una expresión cron (para planificaciones más complejas).
			Pe para que se ejecute todos los dias a determinada hora, o determinado dia de la 
			semana a determinada hora, determinado dia del mes a determinada hora, etc. ****


/////////////////////////////////////MANEJO DE EXCEPCIONES//////////////////////////////////


MANEJAR EXCEPCIONES CON CLASE DTO (MANERA 1)

En controller/ExceptionController.java ---------------------------------

	- WebRequest request -> Se puede hacer que el método reciba este objeto el cual es una interfaz 		proporcionada por Spring que te da acceso a información útil sobre la solicitud HTTP actual.
		- request.getDescription(false).replace("uri=", ""); -> Devuelve en formato string el nombre
			completo del enpoint que provoco la exception.
		- request.getHeader("NombreHeader"); -> Extrae el valor asociado a determinado header en la
			solicitud.
		- request.getParameter("paramName"); -> Extrae el valor asociado a determinado parámetro de
			la solicitud.
			Solo funciona para query parameters (@RequestParam), no para path variables 
			(@PathVariable).******
		- request.getAttribute("nombreAtributoX", nombreAmbito); -> Extrae el valor asociado a 				determinado atributo de la solicitud.
			Ámbitos:
			- WebRequest.SCOPE_REQUEST (solo esta solicitud)
			- WebRequest.SCOPE_SESSION (sesión del usuario)
			- WebRequest.SCOPE_GLOBAL (contexto global)

CUSTOM EXCEPTIONS

Estas exceptiones personalizadas son usadas especialmente en la capa service.
En combinación con el tema anterior pueden ser muy poderosas porque mientras que en la capa service se
lanzan exceptiones personalizadas, en un método controller ya no se envuelve su contenido en un try catch
si no se atrapa específicamente cierta exception personalizada en método dentro de 'ExceptionController'.

En utils/exceptions/NombreClaseCustomException.java ----------------------

public class NombreClaseCustomException extends NombreClaseException {} -> Crea la clase de excpetion 	personalizada.
	En spring boot, Lo mas común es heredar de la excepción llamada RuntimeException. ******

*Dentro de la clase*

public NombreClaseCustomException(String message) {
    super(message);
} -> Constructor usado para crear la excepción con un mensaje descriptivo.
	Este constructor se usa cuando el error no proviene de otra excepción, sino que tú mismo lo defines 	como error en tu lógica, es decir, se usa cuando en el código hay algo asi:
		if(condicion)
			throw new NombreClaseCustomException("Mensaje personalizado")

public AudioProcessingException(String message, Throwable cause) {
    super(message, cause);
} -> Este constructor permite incluir el mensaje + la excepción original que causó el error (cause).
	Aquí se mantiene la traza original del error pero envuelta en tu excepción personalizada.
	Esto es útil porque: No pierdes información del error original, Puedes tener un mensaje más claro 	para tu capa de negocio o tu API y se puee generalizar multiples exceptiones.
	Se usa cuando en el código hay algo asi:
	} catch (CannotReadException e) {
            logger.error("No se puede leer el archivo de audio: {}", e.getMessage());
            throw new AudioProcessingException("Formato de audio no soportado o archivo corrupto", e);
        } catch (IOException e) {
            logger.error("Error de E/S al procesar el archivo: {}", e.getMessage());
            throw new AudioProcessingException("Error al acceder al archivo", e);
        } catch (TagException e) {
            logger.warn("Metadatos corruptos o incompletos: {}", e.getMessage());
            throw new AudioProcessingException("Los metadatos del archivo están corruptos o incompletos", e);
        } 



////////////////////////////PROGRAMACION ORIENTADA A ASPECTOS (AOP)/////////////////////////

DEPURACION


Librería StopWatch ----------------------------

Librería propia de spring boot.
Permite medir el tiempo por partes, pe medir el tiempo para la consulta, la eliminación de archivos, etc.),
asignándole nombre a cada una de estas secciones y mostrando este análisis de una manera elegante en los logs.

StopWatch stopWatch = new StopWatch("Nombre analisis"); -> Crea un stop watch y asigna nombre a la analisis.

stopWatch.start("nombre seccion");
// codigo
stopWatch.stop(); -> Cuenta el tiempo para una sección.

stopWatch.prettyPrint() -> Imprime el tiempo de cada seecion junto con el nombre de las secciones.

stopWatch.getTotalTimeMillis() -> Imprime el tiempo total en milisegundos.


